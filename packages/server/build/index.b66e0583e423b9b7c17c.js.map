{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap","webpack:///C:/projects/bunker42/node_modules/@bunker42/config/app.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/config/db.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/config/engine.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/config/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/config/modules.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-client/clientOnly.tsx","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-client/index.tsx","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/clientStorage.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/createApolloClient.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/createReduxStore.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/log.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/net.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-common/utils.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/api/pubsub.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/api/rootSchema.graphql","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/api/schema.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/api/subscriptions.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/app.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/entry.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/graphql.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/middleware/error.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/middleware/graphiql.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/middleware/website.tsx","webpack:///C:/projects/bunker42/node_modules/@bunker42/core-server/server.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/knexdata.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/sql/connector.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/sql/createTransaction.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/sql/helpers.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/sql/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/database-server/sql/populateTestDb.js","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-client/BaseModule.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-client/ClientModule.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-client/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-common/CommonModule.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-common/GraphQLModule.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-common/Module.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-common/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-server/ServerModule.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/module-server/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/post-server/index.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/post-server/resolvers.ts","webpack:///C:/projects/bunker42/node_modules/@bunker42/post-server/schema.graphql","webpack:///C:/projects/bunker42/node_modules/@bunker42/post-server/sql.ts","webpack:///../src/core/networkStatus.ts","webpack:///../src/util/Observable.ts","webpack:///../src/util/arrays.ts","webpack:///../src/errors/ApolloError.ts","webpack:///../src/core/types.ts","webpack:///../src/core/ObservableQuery.ts","webpack:///../src/data/mutations.ts","webpack:///../src/data/queries.ts","webpack:///../src/util/capitalizeFirstLetter.ts","webpack:///../src/core/LocalState.ts","webpack:///../src/util/observables.ts","webpack:///../src/core/QueryManager.ts","webpack:///../src/data/store.ts","webpack:///../src/version.ts","webpack:///../src/ApolloClient.ts","webpack:///C:/projects/bunker42/node_modules/client/src/index.ts","webpack:///C:/projects/bunker42/node_modules/client/src/modules.ts","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/hot/log-apply-result.js","webpack:///(webpack)/hot/log.js","webpack:///(webpack)/hot/poll.js","webpack:///./src/index.ts","webpack:///./src/modules.ts","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///external \"@babel/runtime/helpers/extends\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///external \"@loadable/server\"","webpack:///external \"apollo-cache-inmemory\"","webpack:///external \"apollo-cache-router\"","webpack:///external \"apollo-link\"","webpack:///external \"apollo-link-batch-http\"","webpack:///external \"apollo-link-schema\"","webpack:///external \"apollo-link-state\"","webpack:///external \"apollo-link-ws\"","webpack:///external \"apollo-logger\"","webpack:///external \"apollo-server-express\"","webpack:///external \"apollo-server-module-graphiql\"","webpack:///external \"apollo-utilities\"","webpack:///external \"compression\"","webpack:///external \"connected-react-router\"","webpack:///external \"dotenv/config\"","webpack:///external \"express\"","webpack:///external \"fractal-objects\"","webpack:///external \"fs\"","webpack:///external \"glob\"","webpack:///external \"graphql\"","webpack:///external \"graphql-resolve-batch\"","webpack:///external \"graphql-subscriptions\"","webpack:///external \"graphql-tools\"","webpack:///external \"graphql/language/visitor\"","webpack:///external \"http\"","webpack:///external \"isomorphic-fetch\"","webpack:///external \"isomorphic-unfetch\"","webpack:///external \"knex\"","webpack:///external \"lodash\"","webpack:///external \"minilog\"","webpack:///external \"module\"","webpack:///external \"objection\"","webpack:///external \"path\"","webpack:///external \"raf/polyfill\"","webpack:///external \"react\"","webpack:///external \"react-apollo\"","webpack:///external \"react-dom/server\"","webpack:///external \"react-helmet\"","webpack:///external \"react-redux\"","webpack:///external \"react-router\"","webpack:///external \"redux\"","webpack:///external \"redux-devtools-extension/developmentOnly\"","webpack:///external \"serialize-javascript\"","webpack:///external \"styled-components\"","webpack:///external \"subscriptions-transport-ws\"","webpack:///external \"symbol-observable\"","webpack:///external \"ts-invariant\"","webpack:///external \"tslib\"","webpack:///external \"url\""],"sourcesContent":[" \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadUpdateChunk(chunkId) {\n \t\tvar chunk = require(\"./\" + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\");\n \t\thotAddUpdateChunk(chunk.id, chunk.modules);\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadManifest() {\n \t\ttry {\n \t\t\tvar update = require(\"./\" + \"\" + hotCurrentHash + \".hot-update.json\");\n \t\t} catch (e) {\n \t\t\treturn Promise.resolve();\n \t\t}\n \t\treturn Promise.resolve(update);\n \t}\n\n \t//eslint-disable-next-line no-unused-vars\n \tfunction hotDisposeChunk(chunkId) {\n \t\tdelete installedChunks[chunkId];\n \t}\n\n \tvar hotApplyOnUpdate = true;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentHash = \"5adc409b1587311c1ae2\";\n \tvar hotRequestTimeout = 10000;\n \tvar hotCurrentModuleData = {};\n \tvar hotCurrentChildModule;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParents = [];\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParentsTemp = [];\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateRequire(moduleId) {\n \t\tvar me = installedModules[moduleId];\n \t\tif (!me) return __webpack_require__;\n \t\tvar fn = function(request) {\n \t\t\tif (me.hot.active) {\n \t\t\t\tif (installedModules[request]) {\n \t\t\t\t\tif (installedModules[request].parents.indexOf(moduleId) === -1) {\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\thotCurrentParents = [moduleId];\n \t\t\t\t\thotCurrentChildModule = request;\n \t\t\t\t}\n \t\t\t\tif (me.children.indexOf(request) === -1) {\n \t\t\t\t\tme.children.push(request);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconsole.warn(\n \t\t\t\t\t\"[HMR] unexpected require(\" +\n \t\t\t\t\t\trequest +\n \t\t\t\t\t\t\") from disposed module \" +\n \t\t\t\t\t\tmoduleId\n \t\t\t\t);\n \t\t\t\thotCurrentParents = [];\n \t\t\t}\n \t\t\treturn __webpack_require__(request);\n \t\t};\n \t\tvar ObjectFactory = function ObjectFactory(name) {\n \t\t\treturn {\n \t\t\t\tconfigurable: true,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: function() {\n \t\t\t\t\treturn __webpack_require__[name];\n \t\t\t\t},\n \t\t\t\tset: function(value) {\n \t\t\t\t\t__webpack_require__[name] = value;\n \t\t\t\t}\n \t\t\t};\n \t\t};\n \t\tfor (var name in __webpack_require__) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\n \t\t\t\tname !== \"e\" &&\n \t\t\t\tname !== \"t\"\n \t\t\t) {\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\n \t\t\t}\n \t\t}\n \t\tfn.e = function(chunkId) {\n \t\t\tif (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n \t\t\thotChunksLoading++;\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\n \t\t\t\tfinishChunkLoading();\n \t\t\t\tthrow err;\n \t\t\t});\n\n \t\t\tfunction finishChunkLoading() {\n \t\t\t\thotChunksLoading--;\n \t\t\t\tif (hotStatus === \"prepare\") {\n \t\t\t\t\tif (!hotWaitingFilesMap[chunkId]) {\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t\t\t}\n \t\t\t\t\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n \t\t\t\t\t\thotUpdateDownloaded();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\tfn.t = function(value, mode) {\n \t\t\tif (mode & 1) value = fn(value);\n \t\t\treturn __webpack_require__.t(value, mode & ~1);\n \t\t};\n \t\treturn fn;\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateModule(moduleId) {\n \t\tvar hot = {\n \t\t\t// private stuff\n \t\t\t_acceptedDependencies: {},\n \t\t\t_declinedDependencies: {},\n \t\t\t_selfAccepted: false,\n \t\t\t_selfDeclined: false,\n \t\t\t_selfInvalidated: false,\n \t\t\t_disposeHandlers: [],\n \t\t\t_main: hotCurrentChildModule !== moduleId,\n\n \t\t\t// Module API\n \t\t\tactive: true,\n \t\t\taccept: function(dep, callback) {\n \t\t\t\tif (dep === undefined) hot._selfAccepted = true;\n \t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n \t\t\t\telse hot._acceptedDependencies[dep] = callback || function() {};\n \t\t\t},\n \t\t\tdecline: function(dep) {\n \t\t\t\tif (dep === undefined) hot._selfDeclined = true;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n \t\t\t\telse hot._declinedDependencies[dep] = true;\n \t\t\t},\n \t\t\tdispose: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\taddDisposeHandler: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\tremoveDisposeHandler: function(callback) {\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n \t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n \t\t\t},\n \t\t\tinvalidate: function() {\n \t\t\t\tthis._selfInvalidated = true;\n \t\t\t\tswitch (hotStatus) {\n \t\t\t\t\tcase \"idle\":\n \t\t\t\t\t\thotUpdate = {};\n \t\t\t\t\t\thotUpdate[moduleId] = modules[moduleId];\n \t\t\t\t\t\thotSetStatus(\"ready\");\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"ready\":\n \t\t\t\t\t\thotApplyInvalidatedModule(moduleId);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"prepare\":\n \t\t\t\t\tcase \"check\":\n \t\t\t\t\tcase \"dispose\":\n \t\t\t\t\tcase \"apply\":\n \t\t\t\t\t\t(hotQueuedInvalidatedModules =\n \t\t\t\t\t\t\thotQueuedInvalidatedModules || []).push(moduleId);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\t// ignore requests in error states\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t},\n\n \t\t\t// Management API\n \t\t\tcheck: hotCheck,\n \t\t\tapply: hotApply,\n \t\t\tstatus: function(l) {\n \t\t\t\tif (!l) return hotStatus;\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\taddStatusHandler: function(l) {\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\tremoveStatusHandler: function(l) {\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\n \t\t\t\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t//inherit from previous dispose call\n \t\t\tdata: hotCurrentModuleData[moduleId]\n \t\t};\n \t\thotCurrentChildModule = undefined;\n \t\treturn hot;\n \t}\n\n \tvar hotStatusHandlers = [];\n \tvar hotStatus = \"idle\";\n\n \tfunction hotSetStatus(newStatus) {\n \t\thotStatus = newStatus;\n \t\tfor (var i = 0; i < hotStatusHandlers.length; i++)\n \t\t\thotStatusHandlers[i].call(null, newStatus);\n \t}\n\n \t// while downloading\n \tvar hotWaitingFiles = 0;\n \tvar hotChunksLoading = 0;\n \tvar hotWaitingFilesMap = {};\n \tvar hotRequestedFilesMap = {};\n \tvar hotAvailableFilesMap = {};\n \tvar hotDeferred;\n\n \t// The update info\n \tvar hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules;\n\n \tfunction toModuleId(id) {\n \t\tvar isNumber = +id + \"\" === id;\n \t\treturn isNumber ? +id : id;\n \t}\n\n \tfunction hotCheck(apply) {\n \t\tif (hotStatus !== \"idle\") {\n \t\t\tthrow new Error(\"check() is only allowed in idle status\");\n \t\t}\n \t\thotApplyOnUpdate = apply;\n \t\thotSetStatus(\"check\");\n \t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n \t\t\tif (!update) {\n \t\t\t\thotSetStatus(hotApplyInvalidatedModules() ? \"ready\" : \"idle\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\thotRequestedFilesMap = {};\n \t\t\thotWaitingFilesMap = {};\n \t\t\thotAvailableFilesMap = update.c;\n \t\t\thotUpdateNewHash = update.h;\n\n \t\t\thotSetStatus(\"prepare\");\n \t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\thotDeferred = {\n \t\t\t\t\tresolve: resolve,\n \t\t\t\t\treject: reject\n \t\t\t\t};\n \t\t\t});\n \t\t\thotUpdate = {};\n \t\t\tvar chunkId = \"index\";\n \t\t\t// eslint-disable-next-line no-lone-blocks\n \t\t\t{\n \t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t}\n \t\t\tif (\n \t\t\t\thotStatus === \"prepare\" &&\n \t\t\t\thotChunksLoading === 0 &&\n \t\t\t\thotWaitingFiles === 0\n \t\t\t) {\n \t\t\t\thotUpdateDownloaded();\n \t\t\t}\n \t\t\treturn promise;\n \t\t});\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotAddUpdateChunk(chunkId, moreModules) {\n \t\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n \t\t\treturn;\n \t\thotRequestedFilesMap[chunkId] = false;\n \t\tfor (var moduleId in moreModules) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n \t\t\thotUpdateDownloaded();\n \t\t}\n \t}\n\n \tfunction hotEnsureUpdateChunk(chunkId) {\n \t\tif (!hotAvailableFilesMap[chunkId]) {\n \t\t\thotWaitingFilesMap[chunkId] = true;\n \t\t} else {\n \t\t\thotRequestedFilesMap[chunkId] = true;\n \t\t\thotWaitingFiles++;\n \t\t\thotDownloadUpdateChunk(chunkId);\n \t\t}\n \t}\n\n \tfunction hotUpdateDownloaded() {\n \t\thotSetStatus(\"ready\");\n \t\tvar deferred = hotDeferred;\n \t\thotDeferred = null;\n \t\tif (!deferred) return;\n \t\tif (hotApplyOnUpdate) {\n \t\t\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\n \t\t\t// avoid triggering uncaught exception warning in Chrome.\n \t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n \t\t\tPromise.resolve()\n \t\t\t\t.then(function() {\n \t\t\t\t\treturn hotApply(hotApplyOnUpdate);\n \t\t\t\t})\n \t\t\t\t.then(\n \t\t\t\t\tfunction(result) {\n \t\t\t\t\t\tdeferred.resolve(result);\n \t\t\t\t\t},\n \t\t\t\t\tfunction(err) {\n \t\t\t\t\t\tdeferred.reject(err);\n \t\t\t\t\t}\n \t\t\t\t);\n \t\t} else {\n \t\t\tvar outdatedModules = [];\n \t\t\tfor (var id in hotUpdate) {\n \t\t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\n \t\t\t\t}\n \t\t\t}\n \t\t\tdeferred.resolve(outdatedModules);\n \t\t}\n \t}\n\n \tfunction hotApply(options) {\n \t\tif (hotStatus !== \"ready\")\n \t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n \t\toptions = options || {};\n \t\treturn hotApplyInternal(options);\n \t}\n\n \tfunction hotApplyInternal(options) {\n \t\thotApplyInvalidatedModules();\n\n \t\tvar cb;\n \t\tvar i;\n \t\tvar j;\n \t\tvar module;\n \t\tvar moduleId;\n\n \t\tfunction getAffectedStuff(updateModuleId) {\n \t\t\tvar outdatedModules = [updateModuleId];\n \t\t\tvar outdatedDependencies = {};\n\n \t\t\tvar queue = outdatedModules.map(function(id) {\n \t\t\t\treturn {\n \t\t\t\t\tchain: [id],\n \t\t\t\t\tid: id\n \t\t\t\t};\n \t\t\t});\n \t\t\twhile (queue.length > 0) {\n \t\t\t\tvar queueItem = queue.pop();\n \t\t\t\tvar moduleId = queueItem.id;\n \t\t\t\tvar chain = queueItem.chain;\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (\n \t\t\t\t\t!module ||\n \t\t\t\t\t(module.hot._selfAccepted && !module.hot._selfInvalidated)\n \t\t\t\t)\n \t\t\t\t\tcontinue;\n \t\t\t\tif (module.hot._selfDeclined) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"self-declined\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tif (module.hot._main) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"unaccepted\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n \t\t\t\t\tvar parentId = module.parents[i];\n \t\t\t\t\tvar parent = installedModules[parentId];\n \t\t\t\t\tif (!parent) continue;\n \t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n \t\t\t\t\t\treturn {\n \t\t\t\t\t\t\ttype: \"declined\",\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\tparentId: parentId\n \t\t\t\t\t\t};\n \t\t\t\t\t}\n \t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n \t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n \t\t\t\t\t\tif (!outdatedDependencies[parentId])\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tdelete outdatedDependencies[parentId];\n \t\t\t\t\toutdatedModules.push(parentId);\n \t\t\t\t\tqueue.push({\n \t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\tid: parentId\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n\n \t\t\treturn {\n \t\t\t\ttype: \"accepted\",\n \t\t\t\tmoduleId: updateModuleId,\n \t\t\t\toutdatedModules: outdatedModules,\n \t\t\t\toutdatedDependencies: outdatedDependencies\n \t\t\t};\n \t\t}\n\n \t\tfunction addAllToSet(a, b) {\n \t\t\tfor (var i = 0; i < b.length; i++) {\n \t\t\t\tvar item = b[i];\n \t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n \t\t\t}\n \t\t}\n\n \t\t// at begin all updates modules are outdated\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n \t\tvar outdatedDependencies = {};\n \t\tvar outdatedModules = [];\n \t\tvar appliedUpdate = {};\n\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\n \t\t\tconsole.warn(\n \t\t\t\t\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\"\n \t\t\t);\n \t\t};\n\n \t\tfor (var id in hotUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\tmoduleId = toModuleId(id);\n \t\t\t\t/** @type {TODO} */\n \t\t\t\tvar result;\n \t\t\t\tif (hotUpdate[id]) {\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\n \t\t\t\t} else {\n \t\t\t\t\tresult = {\n \t\t\t\t\t\ttype: \"disposed\",\n \t\t\t\t\t\tmoduleId: id\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\t/** @type {Error|false} */\n \t\t\t\tvar abortError = false;\n \t\t\t\tvar doApply = false;\n \t\t\t\tvar doDispose = false;\n \t\t\t\tvar chainInfo = \"\";\n \t\t\t\tif (result.chain) {\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n \t\t\t\t}\n \t\t\t\tswitch (result.type) {\n \t\t\t\t\tcase \"self-declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\t\" in \" +\n \t\t\t\t\t\t\t\t\tresult.parentId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"unaccepted\":\n \t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n \t\t\t\t\t\tif (!options.ignoreUnaccepted)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"accepted\":\n \t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n \t\t\t\t\t\tdoApply = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"disposed\":\n \t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n \t\t\t\t\t\tdoDispose = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n \t\t\t\t}\n \t\t\t\tif (abortError) {\n \t\t\t\t\thotSetStatus(\"abort\");\n \t\t\t\t\treturn Promise.reject(abortError);\n \t\t\t\t}\n \t\t\t\tif (doApply) {\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n \t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n \t\t\t\t\t\tif (\n \t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n \t\t\t\t\t\t\t\tresult.outdatedDependencies,\n \t\t\t\t\t\t\t\tmoduleId\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t) {\n \t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n \t\t\t\t\t\t\taddAllToSet(\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n \t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (doDispose) {\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Store self accepted outdated modules to require them later by the module system\n \t\tvar outdatedSelfAcceptedModules = [];\n \t\tfor (i = 0; i < outdatedModules.length; i++) {\n \t\t\tmoduleId = outdatedModules[i];\n \t\t\tif (\n \t\t\t\tinstalledModules[moduleId] &&\n \t\t\t\tinstalledModules[moduleId].hot._selfAccepted &&\n \t\t\t\t// removed self-accepted modules should not be required\n \t\t\t\tappliedUpdate[moduleId] !== warnUnexpectedRequire &&\n \t\t\t\t// when called invalidate self-accepting is not possible\n \t\t\t\t!installedModules[moduleId].hot._selfInvalidated\n \t\t\t) {\n \t\t\t\toutdatedSelfAcceptedModules.push({\n \t\t\t\t\tmodule: moduleId,\n \t\t\t\t\tparents: installedModules[moduleId].parents.slice(),\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\n \t\t\t\t});\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"dispose\" phase\n \t\thotSetStatus(\"dispose\");\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\n \t\t\tif (hotAvailableFilesMap[chunkId] === false) {\n \t\t\t\thotDisposeChunk(chunkId);\n \t\t\t}\n \t\t});\n\n \t\tvar idx;\n \t\tvar queue = outdatedModules.slice();\n \t\twhile (queue.length > 0) {\n \t\t\tmoduleId = queue.pop();\n \t\t\tmodule = installedModules[moduleId];\n \t\t\tif (!module) continue;\n\n \t\t\tvar data = {};\n\n \t\t\t// Call dispose handlers\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n \t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n \t\t\t\tcb = disposeHandlers[j];\n \t\t\t\tcb(data);\n \t\t\t}\n \t\t\thotCurrentModuleData[moduleId] = data;\n\n \t\t\t// disable module (this disables requires from this module)\n \t\t\tmodule.hot.active = false;\n\n \t\t\t// remove module from cache\n \t\t\tdelete installedModules[moduleId];\n\n \t\t\t// when disposing there is no need to call dispose handler\n \t\t\tdelete outdatedDependencies[moduleId];\n\n \t\t\t// remove \"parents\" references from all children\n \t\t\tfor (j = 0; j < module.children.length; j++) {\n \t\t\t\tvar child = installedModules[module.children[j]];\n \t\t\t\tif (!child) continue;\n \t\t\t\tidx = child.parents.indexOf(moduleId);\n \t\t\t\tif (idx >= 0) {\n \t\t\t\t\tchild.parents.splice(idx, 1);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// remove outdated dependency from module children\n \t\tvar dependency;\n \t\tvar moduleOutdatedDependencies;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\n \t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"apply\" phase\n \t\thotSetStatus(\"apply\");\n\n \t\tif (hotUpdateNewHash !== undefined) {\n \t\t\thotCurrentHash = hotUpdateNewHash;\n \t\t\thotUpdateNewHash = undefined;\n \t\t}\n \t\thotUpdate = undefined;\n\n \t\t// insert new code\n \t\tfor (moduleId in appliedUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\n \t\t\t}\n \t\t}\n\n \t\t// call accept handlers\n \t\tvar error = null;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tvar callbacks = [];\n \t\t\t\t\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[i];\n \t\t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\n \t\t\t\t\t\tif (cb) {\n \t\t\t\t\t\t\tif (callbacks.indexOf(cb) !== -1) continue;\n \t\t\t\t\t\t\tcallbacks.push(cb);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor (i = 0; i < callbacks.length; i++) {\n \t\t\t\t\t\tcb = callbacks[i];\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tcb(moduleOutdatedDependencies);\n \t\t\t\t\t\t} catch (err) {\n \t\t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n \t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\n \t\t\t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Load self accepted modules\n \t\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\n \t\t\tmoduleId = item.module;\n \t\t\thotCurrentParents = item.parents;\n \t\t\thotCurrentChildModule = moduleId;\n \t\t\ttry {\n \t\t\t\t__webpack_require__(moduleId);\n \t\t\t} catch (err) {\n \t\t\t\tif (typeof item.errorHandler === \"function\") {\n \t\t\t\t\ttry {\n \t\t\t\t\t\titem.errorHandler(err);\n \t\t\t\t\t} catch (err2) {\n \t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\terror: err2,\n \t\t\t\t\t\t\t\toriginalError: err\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\tif (!error) error = err2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// handle errors in accept handlers and self accepted module load\n \t\tif (error) {\n \t\t\thotSetStatus(\"fail\");\n \t\t\treturn Promise.reject(error);\n \t\t}\n\n \t\tif (hotQueuedInvalidatedModules) {\n \t\t\treturn hotApplyInternal(options).then(function(list) {\n \t\t\t\toutdatedModules.forEach(function(moduleId) {\n \t\t\t\t\tif (list.indexOf(moduleId) < 0) list.push(moduleId);\n \t\t\t\t});\n \t\t\t\treturn list;\n \t\t\t});\n \t\t}\n\n \t\thotSetStatus(\"idle\");\n \t\treturn new Promise(function(resolve) {\n \t\t\tresolve(outdatedModules);\n \t\t});\n \t}\n\n \tfunction hotApplyInvalidatedModules() {\n \t\tif (hotQueuedInvalidatedModules) {\n \t\t\tif (!hotUpdate) hotUpdate = {};\n \t\t\thotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule);\n \t\t\thotQueuedInvalidatedModules = undefined;\n \t\t\treturn true;\n \t\t}\n \t}\n\n \tfunction hotApplyInvalidatedModule(moduleId) {\n \t\tif (!Object.prototype.hasOwnProperty.call(hotUpdate, moduleId))\n \t\t\thotUpdate[moduleId] = modules[moduleId];\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(__webpack_require__.s = 0);\n","export default {\r\n    name: 'Apollo Starter Kit',\r\n    logo: 'logo.svg', // Loaded via webpack and stored in favicon/common/assets\r\n    logging: {\r\n      level: (process.env.npm_config_argv || '').search(/(watch|start)/) >= 0 ? 'debug' : 'info',\r\n      debugSQL: false,\r\n      apolloLogging: (process.env.npm_config_argv || '').search(/(watch|start)/) >= 0\r\n    },\r\n    // Check here for Windows and Mac OS X: https://code.visualstudio.com/docs/editor/command-line#_opening-vs-code-with-urls\r\n    // Use this protocol handler for Linux: https://github.com/sysgears/vscode-handler\r\n    stackFragmentFormat: 'vscode://file/{0}:{1}:{2}'\r\n  };","const db = {\r\n    client: process.env.DB_CLIENT || 'sqlite3',\r\n    connection: {\r\n      host: process.env.DB_HOST,\r\n      user: process.env.DB_USER,\r\n      socketPath: process.env.DB_SOCKET_PATH,\r\n      password: process.env.DB_PASSWORD,\r\n      database: process.env.DB_DATABASE,\r\n      ssl: process.env.DB_SSL,\r\n      multipleStatements: true,\r\n      charset: 'utf8'\r\n    }\r\n  };\r\n  \r\n  const path = require('path');\r\n  \r\n  if (process.env.NODE_ENV === 'test') {\r\n    db.client = 'sqlite3';\r\n  }\r\n  \r\n  if (db.client === 'sqlite3') {\r\n    db.connection = {\r\n      development: {\r\n        filename: path.resolve('./dev-db.sqlite3')\r\n      },\r\n      production: {\r\n        filename: path.resolve('./prod-db.sqlite3')\r\n      },\r\n      test: {\r\n        filename: ':memory:'\r\n      }\r\n    }[process.env.NODE_ENV || 'development'];\r\n    db.pool = {\r\n      afterCreate: (conn, cb) => {\r\n        conn.run('PRAGMA foreign_keys = ON', cb);\r\n      }\r\n    };\r\n  }\r\n  \r\n  export default db;","export default {\r\n    apiKey: process.env.APOLLO_ENGINE_API_KEY, // Set your Apollo Engine API key\r\n    logging: {\r\n      level: 'DEBUG' // Engine Proxy logging level. DEBUG, INFO, WARN or ERROR\r\n    }\r\n  };","import { pickBy, get } from 'lodash';\r\nimport * as modules from './modules';\r\n\r\nconst envSettings = { ...pickBy(modules, (v, k) => k !== 'env'), ...get(modules, 'env.' + process.env.NODE_ENV) };\r\n\r\nexport default envSettings;","export { default as app } from './app';\r\nexport { default as db } from './db';\r\nexport { default as engine } from './engine';\r\n// export { default as rest } from './rest';\r\n// export { default as mailer } from './mailer';\r\n// export { default as analytics } from './analytics';\r\n// export { default as stripe } from './stripe';\r\n// export { default as i18n } from './i18n';\r\n// export { default as pagination } from './pagination';\r\n// export { default as upload } from './upload';\r\n// export { default as chat } from './chat';\r\n// export { default as auth } from './auth';","import React, { Component } from 'react';\r\n\r\nconst clientOnly = (Comp: React.ComponentType) =>\r\n  class ClientOnly extends Component {\r\n    public state = {\r\n      client: !__SSR__ && !__TEST__\r\n    };\r\n    public componentDidMount() {\r\n      this.setState({ client: __CLIENT__ });\r\n    }\r\n    public render() {\r\n      return this.state.client && <Comp {...this.props} />;\r\n    }\r\n  };\r\n\r\nexport default clientOnly;","import { PLATFORM } from '@bunker42/core-common';\r\nexport { default as clientOnly } from './clientOnly';\r\n\r\nexport default __CLIENT__ && PLATFORM === 'web' ? require('./app').default : {};","export const getItem = async (name: string) => window.sessionStorage.getItem(name);\r\nexport const setItem = async (name: string, value: string) => window.sessionStorage.setItem(name, value);\r\nexport const removeItem = async (name: string) => window.sessionStorage.removeItem(name);","import fetch from 'isomorphic-unfetch';\r\nimport { getOperationAST } from 'graphql';\r\nimport { BatchHttpLink } from 'apollo-link-batch-http';\r\nimport { ApolloLink } from 'apollo-link';\r\nimport { withClientState } from 'apollo-link-state';\r\nimport { WebSocketLink } from 'apollo-link-ws';\r\nimport { InMemoryCache } from 'apollo-cache-inmemory';\r\nimport { LoggingLink } from 'apollo-logger';\r\nimport { SubscriptionClient, ConnectionParamsOptions } from 'subscriptions-transport-ws';\r\nimport ApolloClient from 'apollo-client';\r\nimport ApolloCacheRouter from 'apollo-cache-router';\r\nimport { getMainDefinition, hasDirectives } from 'apollo-utilities';\r\nimport { DocumentNode } from 'graphql';\r\nimport { IResolvers } from 'graphql-tools';\r\n\r\nimport settings from '@bunker42/config';\r\n\r\nimport log from './log';\r\n\r\ninterface CreateApolloClientOptions {\r\n  apiUrl?: string;\r\n  createLink?: Array<(getApolloClient: () => ApolloClient<any>) => ApolloLink>;\r\n  createNetLink?: (apiUrl: string, getApolloClient: () => ApolloClient<any>) => ApolloLink;\r\n  connectionParams?: ConnectionParamsOptions[];\r\n  clientResolvers?: { defaults: { [key: string]: any }; resolvers: IResolvers };\r\n}\r\n\r\nconst createApolloClient = ({\r\n  apiUrl,\r\n  createNetLink,\r\n  createLink,\r\n  connectionParams,\r\n  clientResolvers\r\n}: CreateApolloClientOptions): ApolloClient<any> => {\r\n  const netCache = new InMemoryCache();\r\n  const localCache = new InMemoryCache();\r\n  const cache = ApolloCacheRouter.override(\r\n    ApolloCacheRouter.route(\r\n      [netCache, localCache],\r\n      (document: DocumentNode): InMemoryCache => {\r\n        const operationName = (getOperationAST as any)(document).name;\r\n        if (hasDirectives(['client'], document) || (operationName && operationName.value === 'GeneratedClientQuery')) {\r\n          // Pass all @client queries and @client defaults to localCache\r\n          return localCache;\r\n        } else {\r\n          // Pass all the other queries to netCache);\r\n          return netCache;\r\n        }\r\n      }\r\n    ),\r\n    {\r\n      reset: () => {\r\n        // On apolloClient.resetStore() reset only netCache and keep localCache intact\r\n        return netCache.reset();\r\n      }\r\n    }\r\n  );\r\n\r\n  const getApolloClient = (): ApolloClient<any> => client;\r\n\r\n  const queryLink = createNetLink\r\n    ? createNetLink(apiUrl, getApolloClient)\r\n    : new BatchHttpLink({\r\n        uri: apiUrl,\r\n        credentials: 'include',\r\n        fetch\r\n      });\r\n\r\n  let apiLink = queryLink;\r\n  if (apiUrl && (__TEST__ || typeof navigator !== 'undefined')) {\r\n    const finalConnectionParams = {};\r\n    if (connectionParams) {\r\n      for (const connectionParam of connectionParams) {\r\n        Object.assign(finalConnectionParams, (connectionParam as any)());\r\n      }\r\n    }\r\n\r\n    const wsUri = apiUrl.replace(/^http/, 'ws');\r\n\r\n    const globalVar = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\r\n    const webSocketImpl = (globalVar as any).WebSocket || (globalVar as any).MozWebSocket;\r\n\r\n    const wsClient = new SubscriptionClient(\r\n      wsUri,\r\n      {\r\n        reconnect: true,\r\n        connectionParams: finalConnectionParams\r\n      },\r\n      webSocketImpl\r\n    );\r\n\r\n    wsClient.use([\r\n      {\r\n        applyMiddleware(operationOptions, next) {\r\n          Object.assign(operationOptions, finalConnectionParams);\r\n          next();\r\n        }\r\n      }\r\n    ]);\r\n\r\n    wsClient.onDisconnected(() => {\r\n      // console.log('onDisconnected');\r\n    });\r\n\r\n    wsClient.onReconnected(() => {\r\n      // console.log('onReconnected');\r\n    });\r\n\r\n    apiLink = ApolloLink.split(\r\n      ({ query }) => {\r\n        const definition = getMainDefinition(query);\r\n        return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';\r\n      },\r\n      new WebSocketLink(wsClient),\r\n      queryLink\r\n    );\r\n  }\r\n\r\n  const linkState = withClientState({ ...clientResolvers, cache });\r\n\r\n  const allLinks = [\r\n    ...(createLink ? createLink.map((create: any) => create(getApolloClient)) : []),\r\n    linkState,\r\n    apiLink\r\n  ];\r\n\r\n  if (settings.app.logging.apolloLogging && (!__TEST__ || typeof window !== 'undefined')) {\r\n    allLinks.unshift(new LoggingLink({ logger: log.debug.bind(log) }));\r\n  }\r\n\r\n  const clientParams: any = {\r\n    link: ApolloLink.from(allLinks),\r\n    cache,\r\n    resolvers: (clientResolvers || ({} as any)).resolvers\r\n  };\r\n  if (__SSR__ && !__TEST__) {\r\n    if (typeof window !== 'undefined' && window.__APOLLO_STATE__) {\r\n      clientParams.initialState = window.__APOLLO_STATE__;\r\n    } else {\r\n      clientParams.ssrMode = true;\r\n      clientParams.ssrForceFetchDelay = 100;\r\n    }\r\n  }\r\n\r\n  if (__TEST__) {\r\n    clientParams.defaultOptions = {\r\n      query: {\r\n        fetchPolicy: 'no-cache'\r\n      }\r\n    };\r\n  }\r\n\r\n  const client = new ApolloClient(clientParams);\r\n  if (cache.constructor.name !== 'OverrideCache') {\r\n    // Restore Apollo Link State defaults only if we don't use `apollo-cache-router`\r\n    client.onResetStore((linkState as any).writeDefaults);\r\n  }\r\n\r\n  if (typeof window !== 'undefined' && window.__APOLLO_STATE__) {\r\n    cache.restore(window.__APOLLO_STATE__);\r\n  }\r\n\r\n  return client;\r\n};\r\n\r\nexport default createApolloClient;","import { createStore, combineReducers, applyMiddleware, Store, Reducer, DeepPartial, Middleware } from 'redux';\r\nimport { connectRouter } from 'connected-react-router';\r\nimport { composeWithDevTools } from 'redux-devtools-extension/developmentOnly';\r\n\r\nexport const getStoreReducer = (history: any, reducers: any) =>\r\n  combineReducers({\r\n    router: connectRouter(history),\r\n    ...reducers\r\n  });\r\n\r\nconst createReduxStore = (\r\n  reducers: Reducer,\r\n  initialState: DeepPartial<any>,\r\n  history: any,\r\n  routerMiddleware?: Middleware\r\n): Store => {\r\n  return createStore(\r\n    getStoreReducer(history, reducers),\r\n    initialState, // initial state\r\n    routerMiddleware ? composeWithDevTools(applyMiddleware(routerMiddleware)) : undefined\r\n  );\r\n};\r\n\r\nexport default createReduxStore;","import * as clientStorage from './clientStorage';\r\nexport { clientStorage };\r\nexport * from './net';\r\nexport { default as log } from './log';\r\nexport { default as createApolloClient } from './createApolloClient';\r\nexport { default as createReduxStore } from './createReduxStore';\r\nexport * from './createReduxStore';\r\nexport * from './utils';\r\nexport { flowRight as compose } from 'lodash';","import minilog from 'minilog';\r\n\r\nimport settings from '@bunker42/config';\r\n\r\nminilog.enable();\r\n\r\nconst loggerName = typeof window !== 'undefined' ? 'frontend' : 'backend';\r\n\r\nconst log = minilog(loggerName);\r\n(log as any).suggest.defaultResult = false;\r\n(log as any).suggest.clear().allow(loggerName, settings.app.logging.level);\r\n\r\nif (__DEV__ && __SERVER__ && !__TEST__) {\r\n  const consoleLog = global.console.log;\r\n  global.console.log = (...args: any[]) => {\r\n    if (args.length === 1 && typeof args[0] === 'string' && args[0].match(/^\\[(HMR|WDS)\\]/)) {\r\n      consoleLog('backend ' + args[0]);\r\n    } else {\r\n      consoleLog.apply(global.console, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport default log;","import url from 'url';\r\nimport { PLATFORM } from './utils';\r\n\r\nexport const serverPort =\r\n  PLATFORM === 'server' && (process.env.PORT || (typeof __SERVER_PORT__ !== 'undefined' ? __SERVER_PORT__ : 8080));\r\nexport const isApiExternal = !!url.parse(__API_URL__).protocol;\r\n\r\nconst clientApiUrl =\r\n  !isApiExternal && PLATFORM === 'web'\r\n    ? `${window.location.protocol}//${window.location.hostname}${\r\n        __DEV__ ? ':8080' : window.location.port ? ':' + window.location.port : ''\r\n      }${__API_URL__}`\r\n    : __API_URL__;\r\n\r\nconst serverApiUrl = !isApiExternal ? `http://localhost:${serverPort}${__API_URL__}` : __API_URL__;\r\n\r\nexport const apiUrl = PLATFORM === 'server' ? serverApiUrl : clientApiUrl;","import _ from 'lodash';\r\n\r\nimport log from './log';\r\n\r\n/**\r\n * Removes the specified paths from the input object and the nested objects.\r\n * Returns a new object composed of the properties that were not removed.\r\n *\r\n * @param obj - The source object\r\n * @param paths - The property paths to remove\r\n */\r\nexport const omitNested = (obj: { [key: string]: any }, paths: string | string[]) => {\r\n  const omittedObject = _.omit(obj, paths);\r\n\r\n  Object.keys(omittedObject).forEach((key: string) => {\r\n    if (typeof omittedObject[key] === 'object') {\r\n      omittedObject[key] = omitNested(omittedObject[key], paths);\r\n    }\r\n  });\r\n\r\n  return omittedObject;\r\n};\r\n\r\n/**\r\n * Removes the '__typename' field from the incoming object.\r\n *\r\n * @param obj - The source object\r\n */\r\nexport const removeTypename = (obj: { [key: string]: any }) => omitNested(obj, '__typename');\r\n\r\n/**\r\n * Wraps the target object to trace and log all method calls\r\n *\r\n * @param {*} obj target object to trace\r\n */\r\nexport const traceMethodCalls = (obj: any) => {\r\n  return new Proxy(obj, {\r\n    get(target, property) {\r\n      const origProperty = target[property];\r\n      return (...args: any[]) => {\r\n        const result = origProperty.apply(target, args);\r\n        log.debug(`${String(property)}${JSON.stringify(args) + ' -> ' + JSON.stringify(result)}`);\r\n        return result;\r\n      };\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Gets the current platform such as web, server, or mobile\r\n */\r\nconst getPlatform = () => {\r\n  if (typeof document !== 'undefined') {\r\n    return 'web';\r\n  } else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\r\n    return 'mobile';\r\n  } else {\r\n    return 'server';\r\n  }\r\n};\r\n\r\n/**\r\n * Current platform\r\n */\r\nexport const PLATFORM = getPlatform();","import { wrapPubSub } from 'apollo-logger';\r\nimport { PubSub } from 'graphql-subscriptions';\r\n\r\nimport { log } from '@bunker42/core-common';\r\nimport settings from '@bunker42/config';\r\n\r\nconst pubsub = settings.app.logging.apolloLogging\r\n  ? wrapPubSub(new PubSub(), { logger: log.debug.bind(log) })\r\n  : new PubSub();\r\n\r\nexport default pubsub as PubSub;","\n    var doc = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"FieldError\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"field\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"message\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Query\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"dummy\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Mutation\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"dummy\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Subscription\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"dummy\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]}]},{\"kind\":\"SchemaDefinition\",\"directives\":[],\"operationTypes\":[{\"kind\":\"OperationTypeDefinition\",\"operation\":\"query\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Query\"}}},{\"kind\":\"OperationTypeDefinition\",\"operation\":\"mutation\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Mutation\"}}},{\"kind\":\"OperationTypeDefinition\",\"operation\":\"subscription\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Subscription\"}}}]}],\"loc\":{\"start\":0,\"end\":250}};\n    doc.loc.source = {\"body\":\"type FieldError {\\r\\n  field: String!\\r\\n  message: String!\\r\\n}\\r\\n\\r\\ntype Query {\\r\\n  dummy: Int\\r\\n}\\r\\n\\r\\ntype Mutation {\\r\\n  dummy: Int\\r\\n}\\r\\n\\r\\ntype Subscription {\\r\\n  dummy: Int\\r\\n}\\r\\n\\r\\nschema {\\r\\n  query: Query\\r\\n  mutation: Mutation\\r\\n  subscription: Subscription\\r\\n}\",\"name\":\"GraphQL request\",\"locationOffset\":{\"line\":1,\"column\":1}};\n  \r\n\n    var names = {};\n    function unique(defs) {\n      return defs.filter(\n        function(def) {\n          if (def.kind !== 'FragmentDefinition') return true;\n          var name = def.name.value\n          if (names[name]) {\n            return false;\n          } else {\n            names[name] = true;\n            return true;\n          }\n        }\n      )\n    }\n  \r\n\n      module.exports = doc;\n    \r\n","import { makeExecutableSchema } from 'graphql-tools';\r\nimport ServerModule from '@bunker42/module-server';\r\n\r\nimport rootSchemaDef from './rootSchema.graphql';\r\nimport pubsub from './pubsub';\r\n\r\nexport const createSchema = (modules: ServerModule) =>\r\n  makeExecutableSchema({\r\n    typeDefs: [rootSchemaDef].concat(modules.schema),\r\n    resolvers: modules.createResolvers(pubsub)\r\n  });","import { SubscriptionServer, ConnectionContext } from 'subscriptions-transport-ws';\r\nimport { execute, subscribe, GraphQLSchema } from 'graphql';\r\nimport { Server } from 'http';\r\nimport ServerModule from '@bunker42/module-server';\r\nimport { log } from '@bunker42/core-common';\r\n\r\nlet subscriptionServer: SubscriptionServer;\r\n\r\nconst addSubscriptions = (httpServer: Server, schema: GraphQLSchema, modules: ServerModule) => {\r\n  subscriptionServer = SubscriptionServer.create(\r\n    {\r\n      schema,\r\n      execute,\r\n      subscribe,\r\n      onConnect: async (connectionParams: any, webSocket: any, ctx: ConnectionContext) => {\r\n        try {\r\n          return {\r\n            ...(await modules.createContext(null, null, connectionParams, webSocket)),\r\n            wsCtx: ctx\r\n          };\r\n        } catch (e) {\r\n          log.error(e);\r\n        }\r\n      },\r\n      onOperation: async (message: any, params: any, webSocket: any) => {\r\n        try {\r\n          params.context = await modules.createContext(null, null, message.payload, webSocket);\r\n          return params;\r\n        } catch (e) {\r\n          log.error(e);\r\n        }\r\n      }\r\n    },\r\n    {\r\n      server: httpServer,\r\n      path: '/graphql'\r\n    }\r\n  );\r\n};\r\n\r\nconst addGraphQLSubscriptions = (\r\n  httpServer: Server,\r\n  schema: GraphQLSchema,\r\n  modules: ServerModule,\r\n  entryModule?: NodeModule\r\n) => {\r\n  if (entryModule && entryModule.hot && entryModule.hot.data) {\r\n    const prevServer = entryModule.hot.data.subscriptionServer;\r\n    if (prevServer && prevServer.wsServer) {\r\n      log.debug('Reloading the subscription server.');\r\n      prevServer.wsServer.close(() => {\r\n        addSubscriptions(httpServer, schema, modules);\r\n      });\r\n    }\r\n  } else {\r\n    addSubscriptions(httpServer, schema, modules);\r\n  }\r\n};\r\n\r\nexport const onAppDispose = (_: ServerModule, data: any) => {\r\n  data.subscriptionServer = subscriptionServer;\r\n};\r\n\r\nexport default addGraphQLSubscriptions;","import express from 'express';\r\nimport compression from 'compression';\r\nimport path from 'path';\r\nimport { GraphQLSchema } from 'graphql';\r\n\r\nimport { isApiExternal } from '@bunker42/core-common';\r\nimport ServerModule from '@bunker42/module-server';\r\n\r\nimport graphiqlMiddleware from './middleware/graphiql';\r\nimport websiteMiddleware from './middleware/website';\r\nimport createApolloServer from './graphql';\r\nimport errorMiddleware from './middleware/error';\r\n\r\nexport const createServerApp = (schema: GraphQLSchema, modules: ServerModule) => {\r\n  const app = express();\r\n  // Don't rate limit heroku\r\n  app.enable('trust proxy');\r\n\r\n  if (!__DEV__) {\r\n    app.use(compression());\r\n  }\r\n\r\n  (modules.beforeware || []).forEach(applyBeforeware => applyBeforeware(app, modules.appContext));\r\n  (modules.middleware || []).forEach(applyMiddleware => applyMiddleware(app, modules.appContext));\r\n\r\n  if (__DEV__) {\r\n    app.get('/servdir', (req, res) => res.send(process.cwd() + path.sep));\r\n  }\r\n\r\n  if (!isApiExternal) {\r\n    const graphqlServer = createApolloServer(schema, modules);\r\n    graphqlServer.applyMiddleware({ app, path: __API_URL__, cors: { credentials: true, origin: true } });\r\n  }\r\n\r\n  app.get('/graphiql', (req, res, next) => graphiqlMiddleware(req, res, next));\r\n  app.use(websiteMiddleware(schema, modules));\r\n  app.use('/', express.static(__FRONTEND_BUILD_DIR__, { maxAge: '180 days' }));\r\n\r\n  if (__DEV__) {\r\n    app.use(errorMiddleware);\r\n  }\r\n  return app;\r\n};","import { log } from '@bunker42/core-common';\r\nexport { createServer, serverPromise } from './server';\r\n\r\nprocess.on('uncaughtException', ex => {\r\n  log.error(ex);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', reason => {\r\n  log.error(reason);\r\n});","import { ApolloServer, AuthenticationError, ApolloError } from 'apollo-server-express';\r\nimport { formatResponse } from 'apollo-logger';\r\nimport { GraphQLSchema } from 'graphql';\r\nimport 'isomorphic-fetch';\r\n\r\nimport { log } from '@bunker42/core-common';\r\nimport ServerModule from '@bunker42/module-server';\r\nimport settings from '@bunker42/config';\r\n\r\nexport default (schema: GraphQLSchema, modules: ServerModule) => {\r\n  return new ApolloServer({\r\n    schema,\r\n    context: async ({ req, res }: { req: Request; res: Response }) => ({\r\n      ...(await modules.createContext(req, res)),\r\n      req,\r\n      res\r\n    }),\r\n    formatError: (error: ApolloError) =>\r\n      error.message === 'Not Authenticated!' ? new AuthenticationError(error.message) : error,\r\n    formatResponse: (response: any, options: { [key: string]: any }) =>\r\n      settings.app.logging.apolloLogging\r\n        ? formatResponse({ logger: log.debug.bind(log) }, response, options)\r\n        : response,\r\n    tracing: !!settings.engine.apiKey,\r\n    cacheControl: !!settings.engine.apiKey,\r\n    engine: settings.engine.apiKey ? { apiKey: settings.engine.apiKey } : false,\r\n    playground: false\r\n  });\r\n};","import ServerModule from '@bunker42/module-server';\r\n\r\nimport { createServer } from './entry';\r\n\r\nexport { serverPromise } from './entry';\r\nexport { createSchema } from './api/schema';\r\n\r\nexport default new ServerModule({\r\n  onAppCreate: [createServer]\r\n});","import path from 'path';\r\nimport fs from 'fs';\r\nimport { isApiExternal, log } from '@bunker42/core-common';\r\n\r\nlet assetMap: { [key: string]: string };\r\n\r\n/**\r\n * Gets rid of circular data in the object,\r\n * replaces circular links to '[Circular]' string\r\n * It is needed for converting the Error object into JSON via JSON.stringify\r\n */\r\nconst stripCircular = (circularData: any, seen: any[] | null) => {\r\n  const notCircularData = Array.isArray(circularData) ? [] : {};\r\n  seen = seen || [];\r\n  seen.push(circularData);\r\n\r\n  Object.getOwnPropertyNames(circularData).forEach(key => {\r\n    if (!circularData[key] || (typeof circularData[key] !== 'object' && !Array.isArray(circularData[key]))) {\r\n      notCircularData[key] = circularData[key];\r\n    } else if (seen.indexOf(circularData[key]) < 0) {\r\n      notCircularData[key] = stripCircular(circularData[key], seen.slice(0));\r\n    } else {\r\n      notCircularData[key] = '[Circular]';\r\n    }\r\n  });\r\n\r\n  return notCircularData;\r\n};\r\n\r\n/**\r\n * The code below MUST be declared as a function, not closure,\r\n * otherwise Express will fail to execute this handler\r\n *\r\n * Important: should have 4 params, even if they are not used\r\n */\r\nfunction errorMiddleware(e: Error, req: any, res: any, next: () => void) {\r\n  if (!isApiExternal && req.path === __API_URL__) {\r\n    const stack = e.stack.toString().replace(/[\\n]/g, '\\\\n');\r\n    res.status(200).send(`[{\"data\": {}, \"errors\":[{\"message\": \"${stack}\"}]}]`);\r\n  } else {\r\n    log.error(e);\r\n\r\n    if (__DEV__ || !assetMap) {\r\n      assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());\r\n    }\r\n\r\n    res.status(200).send(\r\n      `<html>\r\n            <script charset=\"UTF-8\">window.__SERVER_ERROR__=${JSON.stringify(stripCircular(e, null))};</script>\r\n            <body>\r\n                 <div id=\"root\"></div>\r\n                 ${assetMap['vendor.js'] ? `<script src=\"${assetMap['vendor.js']}\" charSet=\"utf-8\"></script>` : ''}\r\n                 <script src=\"${assetMap['index.js']}\" charSet=\"utf-8\"></script>\r\n          </body>\r\n       </html>`\r\n    );\r\n  }\r\n}\r\n\r\nexport default errorMiddleware;","import * as url from 'url';\r\nimport * as express from 'express';\r\nimport * as GraphiQL from 'apollo-server-module-graphiql';\r\nimport { isApiExternal, serverPort } from '@bunker42/core-common';\r\n\r\ntype ExpressGraphQLOptionsFunction = (req?: express.Request, res?: express.Response) => any | Promise<any>;\r\n\r\nfunction graphiqlExpress(options: GraphiQL.GraphiQLData | ExpressGraphQLOptionsFunction) {\r\n  const graphiqlHandler = (req: express.Request, res: express.Response, next: any) => {\r\n    const query = req.url && url.parse(req.url, true).query;\r\n    GraphiQL.resolveGraphiQLString(query, options, req).then(\r\n      graphiqlString => {\r\n        res.setHeader('Content-Type', 'text/html');\r\n        res.write(graphiqlString);\r\n        res.end();\r\n      },\r\n      error => next(error)\r\n    );\r\n  };\r\n\r\n  return graphiqlHandler;\r\n}\r\n\r\nexport default graphiqlExpress((req: express.Request) => {\r\n  const { protocol, hostname } = url.parse(req.get('Referer') || `http://localhost`);\r\n  const subscriptionsUrl = (!isApiExternal\r\n    ? `${protocol}//${hostname}:${serverPort}${__API_URL__}`\r\n    : __API_URL__\r\n  ).replace(/^http/, 'ws');\r\n\r\n  return {\r\n    endpointURL: '/graphql',\r\n    subscriptionsEndpoint: subscriptionsUrl,\r\n    query: '{\\n' + '  serverCounter {\\n' + '    amount\\n' + '  }\\n' + '}'\r\n  };\r\n});","import React, { ReactElement } from 'react';\r\nimport ReactDOMServer from 'react-dom/server';\r\nimport { SchemaLink } from 'apollo-link-schema';\r\nimport { ApolloProvider, getDataFromTree } from 'react-apollo';\r\nimport { Provider } from 'react-redux';\r\nimport { StaticRouter } from 'react-router';\r\nimport { ServerStyleSheet } from 'styled-components';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport Helmet, { HelmetData } from 'react-helmet';\r\nimport serialize from 'serialize-javascript';\r\nimport { GraphQLSchema } from 'graphql';\r\nimport { ChunkExtractor } from '@loadable/server';\r\n\r\nimport { isApiExternal, apiUrl } from '@bunker42/core-common';\r\nimport ServerModule from '@bunker42/module-server';\r\nimport ClientModule from '@bunker42/module-client';\r\nimport { createApolloClient, createReduxStore } from '@bunker42/core-common';\r\n// import { createApolloClient } from '@bunker42/core-common';\r\n\r\nlet assetMap: { [key: string]: string };\r\n\r\ninterface HtmlProps {\r\n  content: string;\r\n  state: any;\r\n  headElements: Array<ReactElement<{}>>;\r\n  css: Array<ReactElement<{}>>;\r\n  helmet: HelmetData;\r\n}\r\n\r\nlet clientModules: ClientModule;\r\nif (__SSR__) {\r\n  clientModules = require('client').default;\r\n  if (module.hot) {\r\n    module.hot.accept(['client'], () => {\r\n      clientModules = require('client').default;\r\n    });\r\n  }\r\n}\r\n\r\nconst Html = ({ content, state, css, headElements, helmet }: HtmlProps) => (\r\n  <html lang=\"en\" {...helmet.htmlAttributes.toComponent()}>\r\n    <head>\r\n      {helmet.title.toComponent()}\r\n      {helmet.meta.toComponent()}\r\n      {helmet.link.toComponent()}\r\n      {helmet.style.toComponent()}\r\n      {helmet.script.toComponent()}\r\n      {helmet.noscript.toComponent()}\r\n      {assetMap['vendor.js'] && <script src={`${assetMap['vendor.js']}`} charSet=\"utf-8\" />}\r\n      {headElements}\r\n      <meta charSet=\"utf-8\" />\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" />\r\n      <link rel=\"apple-touch-icon\" sizes=\"180x180\" href={`${assetMap['apple-touch-icon.png']}`} />\r\n      <link rel=\"icon\" type=\"image/png\" href={`${assetMap['favicon-32x32.png']}`} sizes=\"32x32\" />\r\n      <link rel=\"icon\" type=\"image/png\" href={`${assetMap['favicon-16x16.png']}`} sizes=\"16x16\" />\r\n      <link rel=\"manifest\" href={`${assetMap['manifest.xjson']}`} />\r\n      <link rel=\"mask-icon\" href={`${assetMap['safari-pinned-tab.svg']}`} color=\"#5bbad5\" />\r\n      <link rel=\"shortcut icon\" href={`${assetMap['favicon.ico']}`} />\r\n      <meta name=\"msapplication-config\" content={`${assetMap['browserconfig.xml']}`} />\r\n      <meta name=\"theme-color\" content=\"#ffffff\" />\r\n      {!!css && css}\r\n    </head>\r\n    <body {...helmet.bodyAttributes.toComponent()}>\r\n      <div id=\"root\" dangerouslySetInnerHTML={{ __html: content || '' }} />\r\n      <script\r\n        dangerouslySetInnerHTML={{\r\n          __html: `window.__APOLLO_STATE__=${serialize(state, {\r\n            isJSON: true\r\n          })};`\r\n        }}\r\n        charSet=\"UTF-8\"\r\n      />\r\n    </body>\r\n  </html>\r\n);\r\n\r\nconst renderServerSide = async (req: any, res: any, schema: GraphQLSchema, modules: ServerModule) => {\r\n  const schemaLink = new SchemaLink({\r\n    schema,\r\n    context: { ...(await modules.createContext(req, res)), req, res }\r\n  });\r\n  const client = createApolloClient({\r\n    apiUrl,\r\n    createNetLink: !isApiExternal ? () => schemaLink : undefined,\r\n    createLink: clientModules.createLink,\r\n    clientResolvers: clientModules.resolvers,\r\n    connectionParams: null\r\n  });\r\n  const store = createReduxStore(clientModules.reducers, {}, client);\r\n  const context: any = {};\r\n  const App = clientModules.getWrappedRoot(\r\n    <Provider store={store}>\r\n      <ApolloProvider client={client}>\r\n        {clientModules.getDataRoot(\r\n          <StaticRouter location={req.url} context={context}>\r\n            {clientModules.router}\r\n          </StaticRouter>\r\n        )}\r\n      </ApolloProvider>\r\n    </Provider>,\r\n    req\r\n  );\r\n\r\n  await getDataFromTree(App);\r\n\r\n  context.pageNotFound === true ? res.status(404) : res.status(200);\r\n\r\n  if (context.url) {\r\n    res.writeHead(307, { Location: context.url });\r\n    res.end();\r\n  } else {\r\n    if (__DEV__ || !assetMap) {\r\n      assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());\r\n      if (!__DEV__ && __CDN_URL__) {\r\n        for (const key of Object.keys(assetMap)) {\r\n          assetMap[key] = __CDN_URL__ + assetMap[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    const extractor = new ChunkExtractor({\r\n      statsFile: path.resolve(__FRONTEND_BUILD_DIR__, 'loadable-stats.json'),\r\n      entrypoints: ['index'],\r\n      publicPath: !__DEV__ && __CDN_URL__ ? __CDN_URL__ : '/'\r\n    });\r\n    const sheet = new ServerStyleSheet();\r\n    const JSX = extractor.collectChunks(sheet.collectStyles(App));\r\n\r\n    const content = ReactDOMServer.renderToString(JSX);\r\n    const helmet = Helmet.renderStatic(); // Avoid memory leak while tracking mounted instances\r\n\r\n    const htmlProps: HtmlProps = {\r\n      content,\r\n      headElements: [...extractor.getScriptElements(), ...extractor.getLinkElements(), ...extractor.getStyleElements()],\r\n      css: sheet.getStyleElement().map((el, idx) => (el ? React.cloneElement(el, { key: idx }) : el)),\r\n      helmet,\r\n      state: { ...client.cache.extract() }\r\n    };\r\n\r\n    res.send(`<!doctype html>\\n${ReactDOMServer.renderToStaticMarkup(<Html {...htmlProps} />)}`);\r\n    res.end();\r\n  }\r\n};\r\n\r\nexport default (schema: GraphQLSchema, modules: ServerModule) => async (\r\n  req: any,\r\n  res: any,\r\n  next: (e?: Error) => void\r\n) => {\r\n  try {\r\n    if (req.path.indexOf('.') < 0 && __SSR__) {\r\n      return await renderServerSide(req, res, schema, modules);\r\n    } else if (req.path.indexOf('.') < 0 && !__SSR__ && req.method === 'GET' && !__DEV__) {\r\n      res.sendFile(path.resolve(__FRONTEND_BUILD_DIR__, 'index.html'));\r\n    } else {\r\n      next();\r\n    }\r\n  } catch (e) {\r\n    next(e);\r\n  }\r\n};","import http from 'http';\r\nimport { serverPort, log } from '@bunker42/core-common';\r\nimport ServerModule from '@bunker42/module-server';\r\nimport { createSchema } from './api/schema';\r\n\r\nimport addGraphQLSubscriptions from './api/subscriptions';\r\n\r\nimport { createServerApp } from './app';\r\n\r\nimport { onAppDispose } from './api/subscriptions';\r\n\r\nlet server: http.Server;\r\n\r\nconst ref: { modules: ServerModule; resolve: (server: http.Server) => void } = {\r\n  modules: null,\r\n  resolve: null\r\n};\r\n\r\nexport const serverPromise: Promise<http.Server> = new Promise(resolve => (ref.resolve = resolve));\r\n\r\nexport const createServer = async (modules: ServerModule, entryModule: NodeModule) => {\r\n  try {\r\n    ref.modules = modules;\r\n\r\n    if (entryModule.hot) {\r\n      entryModule.hot.dispose(data => onAppDispose(modules, data));\r\n      entryModule.hot.status(event => {\r\n        if (event === 'abort' || event === 'fail') {\r\n          console.error('HMR error status: ' + event);\r\n          // Signal webpack.run.js to do full-reload of the back-end\r\n          process.exit(250);\r\n        }\r\n      });\r\n      entryModule.hot.accept();\r\n    }\r\n\r\n    if (!server || !entryModule.hot || !entryModule.hot.data) {\r\n      server = http.createServer();\r\n\r\n      const schema = createSchema(modules);\r\n\r\n      server.on('request', createServerApp(schema, modules));\r\n      addGraphQLSubscriptions(server, schema, modules);\r\n\r\n      server.listen(serverPort, () => {\r\n        log.info(`API is now running on port ${serverPort}`);\r\n        ref.resolve(server);\r\n      });\r\n\r\n      server.on('close', () => {\r\n        server = undefined;\r\n      });\r\n    } else {\r\n      const schema = createSchema(ref.modules);\r\n      server.removeAllListeners('request');\r\n      server.on('request', createServerApp(schema, ref.modules));\r\n      addGraphQLSubscriptions(server, schema, ref.modules, entryModule);\r\n    }\r\n  } catch (e) {\r\n    log.error(e);\r\n  }\r\n};\r\n\r\nif (module.hot) {\r\n  module.hot.dispose(() => {\r\n    // Shutdown server if changes to this module code are made\r\n    // So that it was started afresh\r\n    try {\r\n      if (server) {\r\n        server.close();\r\n        server = undefined;\r\n      }\r\n    } catch (error) {\r\n      log(error.stack);\r\n    }\r\n  });\r\n}","export * from './sql';","import * as glob from 'glob';\r\nimport * as path from 'path';\r\n\r\nimport settings from '@bunker42/config';\r\n\r\n// This code gathers migrations and seeds from all modules into two fake directories\r\n// /module-migrations - contains all the migrations from all modules\r\n// /module-seeds - contains all the seeds from all modules\r\n// This hack is needed because knex do not support multiple dirs for migrations and seeds\r\n// at the moment. When knex will support multiple dirs for migrations and seeds this hack can be removed\r\nconst fs = require('fs');\r\nconst Module = require('module');\r\n\r\nconst modulesDir = path.isAbsolute(__dirname) ? path.join(__dirname, '../..') : path.resolve('../../modules');\r\nconst virtualDirs = {\r\n  [path.resolve('/module-migrations')]: glob.sync(path.join(modulesDir, '**/migrations')),\r\n  [path.resolve('/module-seeds')]: glob.sync(path.join(modulesDir, '**/seeds'))\r\n};\r\nconst virtualFiles = {};\r\n\r\nconst realResolve = Module._resolveFilename;\r\nModule._resolveFilename = function fakeResolve(request, parent) {\r\n  const normRequest = request.replace(/\\\\/g, '/');\r\n  if (virtualFiles[normRequest]) {\r\n    return virtualFiles[normRequest];\r\n  } else {\r\n    const result = realResolve(request, parent);\r\n    return result;\r\n  }\r\n};\r\n\r\nfor (const virtualDir of Object.keys(virtualDirs)) {\r\n  const realDirs = virtualDirs[virtualDir];\r\n  for (const realDir of realDirs) {\r\n    const realFiles = fs.readdirSync(realDir);\r\n    for (const file of realFiles) {\r\n      virtualFiles[path.join(virtualDir, file).replace(/\\\\/g, '/')] = path.join(realDir, file);\r\n    }\r\n  }\r\n}\r\n\r\nconst origReaddir = fs.readdir;\r\nfs.readdir = function() {\r\n  const path = arguments[0];\r\n  if (virtualDirs[path]) {\r\n    let files = [];\r\n    for (const dir of virtualDirs[path]) {\r\n      files = files.concat(fs.readdirSync(dir));\r\n    }\r\n    arguments[arguments.length == 2 ? 1 : 2](null, files);\r\n  }\r\n  origReaddir.apply(fs, arguments);\r\n};\r\n\r\nconst envSettings = {\r\n  [process.env.NODE_ENV || 'development']: {\r\n    ...settings.db,\r\n    seeds: {\r\n      directory: '/module-seeds' // fake dir created virtually by tools/knex\r\n    },\r\n    migrations: {\r\n      directory: '/module-migrations' // fake dir created virtually by tools/knex\r\n    },\r\n    useNullAsDefault: true\r\n  }\r\n};\r\n\r\nexport const development = envSettings.development;\r\nexport const production = envSettings.production;\r\nexport const test = envSettings.test;","import knex from 'knex';\r\nimport { Model } from 'objection';\r\nimport * as environments from '../knexdata';\r\n\r\n// eslint-disable-next-line import/namespace\r\nconst knexObj = knex(environments[process.env.NODE_ENV || 'development']);\r\n\r\n// Give the knex instance to objection.\r\nModel.knex(knexObj);\r\n\r\nexport default knexObj;","import { knex } from '.';\r\n\r\nexport default async () => new Promise(resolve => knex.transaction(resolve));","import { groupBy } from 'lodash';\r\n\r\nimport settings from '@bunker42/config';\r\n\r\nexport const returnId = knexTable => (settings.db.client === 'sqlite3' ? knexTable : knexTable.returning('id'));\r\n\r\nexport const truncateTables = async (knex, Promise, tables) => {\r\n  if (settings.db.client === 'sqlite3') {\r\n    return Promise.all(tables.map(table => knex(table).truncate()));\r\n  } else if (['mysql', 'mysql2'].indexOf(settings.db.client) >= 0) {\r\n    return knex.transaction(async function(trx) {\r\n      await knex.raw('SET FOREIGN_KEY_CHECKS=0').transacting(trx);\r\n      await Promise.all(tables.map(table => knex.raw(`TRUNCATE TABLE ${table}`).transacting(trx)));\r\n      await trx.commit;\r\n      await knex.raw('SET FOREIGN_KEY_CHECKS=1').transacting(trx);\r\n    });\r\n  } else if (settings.db.client === 'pg') {\r\n    return Promise.all(tables.map(table => knex.raw(`TRUNCATE \"${table}\" RESTART IDENTITY CASCADE`)));\r\n  }\r\n};\r\n\r\nexport const orderedFor = (rows, collection, field, singleObject) => {\r\n  // return the rows ordered for the collection\r\n  const inGroupsOfField = groupBy(rows, field);\r\n  return collection.map(element => {\r\n    const elementArray = inGroupsOfField[element];\r\n    if (elementArray) {\r\n      return singleObject ? elementArray[0] : elementArray;\r\n    }\r\n    return singleObject ? {} : [];\r\n  });\r\n};","export { default as knex } from './connector';\r\nexport { default as populateTestDb } from './populateTestDb';\r\nexport { default as createTransaction } from './createTransaction';\r\nexport * from './helpers';","import knex from './connector';\r\n\r\nexport default async () => {\r\n  await knex.migrate.latest();\r\n  return knex.seed.run();\r\n};","import React from 'react';\r\nimport { merge } from 'lodash';\r\nimport { ReducersMapObject } from 'redux';\r\n\r\nimport { GraphQLModule, GraphQLModuleShape } from '@bunker42/module-common';\r\n\r\n/**\r\n * Common module interface for React and React Native feature modules\r\n */\r\nexport interface BaseModuleShape extends GraphQLModuleShape {\r\n  // Redux reducers list\r\n  reducer?: ReducersMapObject[];\r\n  // React element that does client-side routing, see `router` feature module\r\n  router?: React.ReactElement<any>;\r\n  // Root component factory list\r\n  rootComponentFactory?: RootComponentFactory[];\r\n  // Data root React elements list (data root elements wraps data fetching react subtree root)\r\n  dataRootComponent?: React.ComponentType[];\r\n}\r\n\r\n/**\r\n * A function that creates React Element that wraps root element of a React tree\r\n */\r\ntype RootComponentFactory = (req: Request) => React.ReactElement<any>;\r\n\r\ninterface BaseModule extends BaseModuleShape {}\r\n\r\n/**\r\n * Base module ancestor for React and React Native feature modules.\r\n */\r\nclass BaseModule extends GraphQLModule {\r\n  /**\r\n   * Constructs base module representation, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: BaseModuleShape[]) {\r\n    super(...modules);\r\n  }\r\n\r\n  /**\r\n   * @returns Redux reducers\r\n   */\r\n  get reducers() {\r\n    return merge({}, ...(this.reducer || []));\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param root React tree data root component (first React root components which is used for fetching data)\r\n   *\r\n   * @returns React tree data root component wrapped up by data root components exposed by this module\r\n   */\r\n  public getDataRoot(root: React.ReactElement<any>) {\r\n    let nestedRoot = root;\r\n    for (const component of this.dataRootComponent || []) {\r\n      nestedRoot = React.createElement(component, {}, nestedRoot);\r\n    }\r\n    return nestedRoot;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param root React tree root component\r\n   *\r\n   * @returns React tree root component wrapped up by root components exposed by this module\r\n   */\r\n  public getWrappedRoot(root: React.ReactElement<any>, req?: Request) {\r\n    let nestedRoot = root;\r\n    for (const componentFactory of this.rootComponentFactory || []) {\r\n      nestedRoot = React.cloneElement(componentFactory(req), {}, nestedRoot);\r\n    }\r\n    return nestedRoot;\r\n  }\r\n}\r\n\r\nexport default BaseModule;\r\n","import React from 'react';\r\nimport BaseModule, { BaseModuleShape } from './BaseModule';\r\n\r\n/**\r\n * React client feature modules interface.\r\n */\r\nexport interface ClientModuleShape extends BaseModuleShape {\r\n  // Route list\r\n  route?: Array<React.ReactElement<any>>;\r\n  // Top left navigation links\r\n  navItem?: Array<React.ReactElement<any>>;\r\n  // Top right navigation links\r\n  navItemRight?: Array<React.ReactElement<any>>;\r\n}\r\n\r\ninterface ClientModule extends ClientModuleShape {}\r\n\r\n/**\r\n * React client feature module implementation.\r\n */\r\nclass ClientModule extends BaseModule {\r\n  /**\r\n   * Constructs React client feature module representation, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: ClientModuleShape[]) {\r\n    super(...modules);\r\n  }\r\n\r\n  /**\r\n   * @returns client-side React route components list\r\n   */\r\n  get routes() {\r\n    return (this.route || []).map(\r\n      (component: React.ReactElement<any>, idx: number, items: Array<React.ReactElement<any>>) =>\r\n        React.cloneElement(component, { key: component.key || idx + items.length })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns client-side top left navbar link component list\r\n   */\r\n  get navItems() {\r\n    return (this.navItem || []).map(\r\n      (component: React.ReactElement<any>, idx: number, items: Array<React.ReactElement<any>>) =>\r\n        React.cloneElement(component, {\r\n          key: component.key || idx + items.length\r\n        })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns client-side top right navbar link component list\r\n   */\r\n  get navItemsRight() {\r\n    return (this.navItemRight || []).map(\r\n      (component: React.ReactElement<any>, idx: number, items: Array<React.ReactElement<any>>) =>\r\n        React.cloneElement(component, {\r\n          key: component.key || idx + items.length\r\n        })\r\n    );\r\n  }\r\n}\r\n\r\nexport default ClientModule;","export { default as BaseModule } from './BaseModule';\r\nexport * from './BaseModule';\r\nexport { default } from './ClientModule';\r\nexport * from './ClientModule';","import { Resource } from 'i18next';\r\n\r\nimport Module, { ModuleShape } from './Module';\r\n\r\n/**\r\n * Common ancestor for server and client feature modules interfaces.\r\n */\r\nexport interface CommonModuleShape extends ModuleShape {\r\n  // Localizations for `i18next` library\r\n  localization?: Array<{ ns: string; resources: Resource }>;\r\n  // Feature modules shared context\r\n  appContext?: { [key: string]: any };\r\n}\r\n\r\ninterface CommonModule extends CommonModuleShape {}\r\n\r\n/**\r\n * Common ancestor for client and server feature modules.\r\n */\r\nclass CommonModule extends Module {\r\n  /**\r\n   * A constructor of common module, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: CommonModuleShape[]) {\r\n    super(...modules);\r\n  }\r\n\r\n  /**\r\n   * @returns localization for i18next library\r\n   */\r\n  get localizations() {\r\n    return this.localization || [];\r\n  }\r\n}\r\n\r\nexport default CommonModule;","import { merge } from 'lodash';\r\nimport { ApolloLink } from 'apollo-link';\r\nimport { ApolloClient } from 'apollo-client';\r\nimport { ConnectionParamsOptions } from 'subscriptions-transport-ws';\r\nimport { IResolvers } from 'graphql-tools';\r\n\r\nimport CommonModule, { CommonModuleShape } from './CommonModule';\r\n\r\n/**\r\n * A function to create non-network Apollo Link that wraps in some way network link.\r\n * There can be multiple non-network links.\r\n *\r\n * @param getApolloClient a function that the link can call later to get instance of Apollo Client\r\n *\r\n * @returns Apollo Link instance\r\n */\r\ntype CreateApolloLink = (getApolloClient: () => ApolloClient<any>) => ApolloLink;\r\n\r\n/**\r\n * A function to create Apollo GraphQL link which is used for network communication.\r\n * The network link can be only one.\r\n *\r\n * @param apiUrl the URL to GraphQL server endpoint\r\n * @param getApolloClient a function that the link can call later to get instance of Apollo Client\r\n *\r\n * @returns Apollo Link instance\r\n */\r\ntype CreateNetLink = (apiUrl: string, getApolloClient: () => ApolloClient<any>) => ApolloLink;\r\n\r\n/**\r\n * Apollo Link State default state and client resolvers\r\n */\r\ninterface ApolloLinkStateParams {\r\n  // Default state\r\n  defaults: { [key: string]: any };\r\n  // Client-side resolvers\r\n  resolvers: IResolvers;\r\n}\r\n\r\n/**\r\n * Client-side GraphQL feature module interface.\r\n */\r\nexport interface GraphQLModuleShape extends CommonModuleShape {\r\n  // Array of functions to create non-network Apollo Link\r\n  createLink?: CreateApolloLink[];\r\n  // A singleton to create network link\r\n  createNetLink?: CreateNetLink;\r\n  // `subscription-transport-ws` WebSocket connection options\r\n  connectionParam?: ConnectionParamsOptions[];\r\n  // Apollo Link State default state and client resolvers\r\n  resolver?: ApolloLinkStateParams[];\r\n}\r\n\r\ninterface GraphQLModule extends GraphQLModuleShape {}\r\n\r\n/**\r\n * Common GraphQL client-side modules ancestor for feature modules of a GraphQL application.\r\n */\r\nclass GraphQLModule extends CommonModule {\r\n  /**\r\n   * Constructs GraphQL feature module representation, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: GraphQLModuleShape[]) {\r\n    super(...modules);\r\n  }\r\n\r\n  /**\r\n   * @returns Apollo Link State client-side resolvers\r\n   */\r\n  get resolvers() {\r\n    return merge({}, ...(this.resolver || []));\r\n  }\r\n\r\n  /**\r\n   * @returns `subscription-transport-ws` WebSocket connection options\r\n   */\r\n  get connectionParams() {\r\n    return this.connectionParam || [];\r\n  }\r\n}\r\n\r\nexport default GraphQLModule;","import { foldTo } from 'fractal-objects';\r\n\r\n/**\r\n * Interface that must be implemented by all the feature modules\r\n * in the application.\r\n *\r\n */\r\nexport interface ModuleShape {\r\n  /**\r\n   * A hook called on the very start of the application,\r\n   * right after all the feature modules are imported.\r\n   */\r\n  onAppCreate?: Array<(modules: Module, entryModule: NodeModule) => Promise<any>>;\r\n}\r\n\r\n/**\r\n *  This way we add all the methods declared in `ModuleShape` into `Module` class\r\n *  and have `Module` implementing `ModuleShape` interface.\r\n */\r\ninterface Module extends ModuleShape {}\r\n\r\n/**\r\n * This class implements `ModuleShape` interface.\r\n *\r\n * It is a very minimalistic feature module implementation, that\r\n * has only `createApp` function.\r\n */\r\nclass Module {\r\n  /**\r\n   * Constructs feature module representation, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: ModuleShape[]) {\r\n    foldTo(this, modules);\r\n  }\r\n\r\n  /**\r\n   * Calls each feature module `onAppCreate` hook, with `module` object as a first argument\r\n   * (see below) and the list of all the feature modules as a second argument,\r\n   * extending this `ModuleShape` interface.\r\n   *\r\n   * In `onAppCreate` hook each module can initialize itself. Usually the `core` feature\r\n   * module in `onAppCreate` hook initializes used framework and registers callbacks\r\n   * exported by other feature modules. And then the framework calls these callbacks.\r\n   *\r\n   * @param entryModule a `module` object generated by Webpack for the very first entry javascript file\r\n   *    of the application. Webpack exposes Webpack Hot Module Replacement API in `module.hot` for\r\n   *    each javascript file. To have maximum control we need only entry file `module.hot` object.\r\n   *    We use this API to quickly and properly reload application code after recompilation happens\r\n   *    during development. `module.hot` is not available, when application code is built for\r\n   *    production mode.\r\n   */\r\n  public async createApp(entryModule: NodeModule) {\r\n    if (this.onAppCreate) {\r\n      for (const callback of this.onAppCreate) {\r\n        await callback(this, entryModule);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Module;","export { default } from './CommonModule';\r\nexport * from './CommonModule';\r\nexport { default as GraphQLModule } from './GraphQLModule';\r\nexport * from './GraphQLModule';","import { merge } from 'lodash';\r\nimport { DocumentNode } from 'graphql';\r\nimport { PubSub } from 'graphql-subscriptions';\r\nimport { Express } from 'express';\r\nimport { ConnectionParamsOptions } from 'subscriptions-transport-ws';\r\nimport { IResolvers } from 'graphql-tools';\r\nimport CommonModule, { CommonModuleShape } from '@bunker42/module-common';\r\nimport { IncomingMessage } from 'http';\r\n\r\n/**\r\n * A function to create GraphQL context\r\n *\r\n * @param props various params passed to function\r\n *\r\n * @returns an object which will be merged into GraphQL context object\r\n */\r\ntype CreateContextFunc = (props: CreateContextFuncProps) => { [key: string]: any };\r\n\r\n/**\r\n * Create GraphQL context function params\r\n */\r\ninterface CreateContextFuncProps {\r\n  // HTTP request\r\n  req: IncomingMessage;\r\n  // HTTP response\r\n  res: Response;\r\n  // `subscriptions-transport-ws` WebSocket connection params\r\n  connectionParams: ConnectionParamsOptions;\r\n  // webSocket implementation\r\n  webSocket: WebSocket;\r\n  // Current GraphQL context object\r\n  graphqlContext: { [key: string]: any };\r\n  // Application context object\r\n  appContext: { [key: string]: any };\r\n}\r\n\r\n/**\r\n * A function to create GraphQL resolvers\r\n *\r\n * @param pubsub a publish subscribe engine for GraphQL subscriptions\r\n *\r\n * @returns GraphQL resolvers\r\n */\r\ntype CreateResolversFunc = (pubsub: PubSub) => IResolvers;\r\n\r\n/**\r\n * A function which registers new middleware.\r\n *\r\n * @param app an instance of Express\r\n * @param appContext application context\r\n */\r\ntype MiddlewareFunc = (app: Express, appContext: { [key: string]: any }) => void;\r\n\r\n/**\r\n * Server feature modules interface\r\n */\r\nexport interface ServerModuleShape extends CommonModuleShape {\r\n  // A GraphQL schema list of a module\r\n  schema?: DocumentNode[];\r\n  // A list of functions to create GraphQL resolvers\r\n  createResolversFunc?: CreateResolversFunc[];\r\n  // A list of functions to create GraphQL context\r\n  createContextFunc?: CreateContextFunc[];\r\n  // A list of functions to register high-priority middlewares (happens before registering normal priority ones)\r\n  beforeware?: MiddlewareFunc[];\r\n  // A list of functions to register normal-priority middlewares\r\n  middleware?: MiddlewareFunc[];\r\n}\r\n\r\ninterface ServerModule extends ServerModuleShape {}\r\n\r\n/**\r\n * A class that represents server-side feature module\r\n *\r\n * An instance of this class is exported by each Node backend feature module\r\n */\r\nclass ServerModule extends CommonModule {\r\n  /**\r\n   * Constructs backend Node feature module representation, that folds all the feature modules\r\n   * into a single module represented by this instance.\r\n   *\r\n   * @param modules feature modules\r\n   */\r\n  constructor(...modules: ServerModuleShape[]) {\r\n    super(...modules);\r\n  }\r\n\r\n  /**\r\n   * @returns list of GraphQL schemas exported by the feature module represented by this class\r\n   */\r\n  public get schemas() {\r\n    return this.schema || [];\r\n  }\r\n\r\n  /**\r\n   * Creates GraphQL context for this module\r\n   *\r\n   * @param req HTTP request\r\n   * @param res HTTP response\r\n   * @param connectionParams `subscriptions-transport-ws` webSocket connnection params\r\n   * @param webSocket WebSockets implementation\r\n   *\r\n   * @returns GraphQL context\r\n   */\r\n  public async createContext(\r\n    req: IncomingMessage,\r\n    res: Response,\r\n    connectionParams?: ConnectionParamsOptions,\r\n    webSocket?: WebSocket\r\n  ) {\r\n    const appContext = this.appContext;\r\n    let graphqlContext = {};\r\n\r\n    for (const createContextFunc of this.createContextFunc || []) {\r\n      graphqlContext = merge(\r\n        graphqlContext,\r\n        await createContextFunc({ req, res, connectionParams, webSocket, graphqlContext, appContext })\r\n      );\r\n    }\r\n    return graphqlContext;\r\n  }\r\n\r\n  /**\r\n   * Creates GraphQL resolvers exported by this module.\r\n   *\r\n   * @param pubsub Publish subscribe engine for GraphQL subscriptions\r\n   *\r\n   * @returns GraphQL resolvers\r\n   */\r\n  public createResolvers(pubsub: PubSub) {\r\n    return merge({}, ...(this.createResolversFunc.map(createResolvers => createResolvers(pubsub)) || []));\r\n  }\r\n}\r\n\r\nexport default ServerModule;","export { default } from './ServerModule';\r\nexport * from './ServerModule';","import ServerModule from '@bunker42/module-server';\r\n\r\nimport Post from './sql';\r\nimport schema from './schema.graphql';\r\nimport createResolvers from './resolvers';\r\n\r\nexport default new ServerModule({\r\n  schema: [schema],\r\n  createResolversFunc: [createResolvers],\r\n  createContextFunc: [() => ({ Post: new Post() })]\r\n});","import { PubSub, withFilter } from 'graphql-subscriptions';\r\nimport { createBatchResolver } from 'graphql-resolve-batch';\r\n// interfaces\r\nimport { Post, Comment, Identifier } from './sql';\r\n\r\ninterface Edges {\r\n  cursor: number;\r\n  node: Post & Identifier;\r\n}\r\n\r\ninterface PostsParams {\r\n  limit: number;\r\n  after: number;\r\n}\r\n\r\ninterface PostInput {\r\n  input: Post;\r\n}\r\n\r\ninterface PostInputWithId {\r\n  input: Post & Identifier;\r\n}\r\n\r\ninterface CommentInput {\r\n  input: Comment;\r\n}\r\n\r\ninterface CommentInputWithId {\r\n  input: Comment & Identifier;\r\n}\r\n\r\nconst POST_SUBSCRIPTION = 'post_subscription';\r\nconst POSTS_SUBSCRIPTION = 'posts_subscription';\r\nconst COMMENT_SUBSCRIPTION = 'comment_subscription';\r\n\r\nexport default (pubsub: PubSub) => ({\r\n  Query: {\r\n    async posts(obj: any, { limit, after }: PostsParams, context: any) {\r\n      const edgesArray: Edges[] = [];\r\n      const posts = await context.Post.postsPagination(limit, after);\r\n      const total = (await context.Post.getTotal()).count;\r\n      const hasNextPage = total > after + limit;\r\n\r\n      posts.map((post: Post & Identifier, index: number) => {\r\n        edgesArray.push({\r\n          cursor: after + index,\r\n          node: post\r\n        });\r\n      });\r\n      const endCursor = edgesArray.length > 0 ? edgesArray[edgesArray.length - 1].cursor : 0;\r\n\r\n      return {\r\n        totalCount: total,\r\n        edges: edgesArray,\r\n        pageInfo: {\r\n          endCursor,\r\n          hasNextPage\r\n        }\r\n      };\r\n    },\r\n    post(obj: any, { id }: Identifier, context: any) {\r\n      return context.Post.post(id);\r\n    }\r\n  },\r\n  Post: {\r\n    comments: createBatchResolver((sources, args, context) => {\r\n      return context.Post.getCommentsForPostIds(sources.map(({ id }) => id));\r\n    })\r\n  },\r\n  Mutation: {\r\n    async addPost(obj: any, { input }: PostInput, context: any) {\r\n      const [id] = await context.Post.addPost(input);\r\n      const post = await context.Post.post(id);\r\n      // publish for post list\r\n      pubsub.publish(POSTS_SUBSCRIPTION, {\r\n        postsUpdated: {\r\n          mutation: 'CREATED',\r\n          id,\r\n          node: post\r\n        }\r\n      });\r\n      return post;\r\n    },\r\n    async deletePost(obj: any, { id }: Identifier, context: any) {\r\n      const post = await context.Post.post(id);\r\n      const isDeleted = await context.Post.deletePost(id);\r\n      if (isDeleted) {\r\n        // publish for post list\r\n        pubsub.publish(POSTS_SUBSCRIPTION, {\r\n          postsUpdated: {\r\n            mutation: 'DELETED',\r\n            id,\r\n            node: post\r\n          }\r\n        });\r\n        // publish for edit post page\r\n        pubsub.publish(POST_SUBSCRIPTION, {\r\n          postUpdated: {\r\n            mutation: 'DELETED',\r\n            id,\r\n            node: post\r\n          }\r\n        });\r\n        return { id: post.id };\r\n      } else {\r\n        return { id: null };\r\n      }\r\n    },\r\n    async editPost(obj: any, { input }: PostInputWithId, context: any) {\r\n      await context.Post.editPost(input);\r\n      const post = await context.Post.post(input.id);\r\n      // publish for post list\r\n      pubsub.publish(POSTS_SUBSCRIPTION, {\r\n        postsUpdated: {\r\n          mutation: 'UPDATED',\r\n          id: post.id,\r\n          node: post\r\n        }\r\n      });\r\n      // publish for edit post page\r\n      pubsub.publish(POST_SUBSCRIPTION, {\r\n        postUpdated: {\r\n          mutation: 'UPDATED',\r\n          id: post.id,\r\n          node: post\r\n        }\r\n      });\r\n      return post;\r\n    },\r\n    async addComment(obj: any, { input }: CommentInput, context: any) {\r\n      const [id] = await context.Post.addComment(input);\r\n      const comment = await context.Post.getComment(id);\r\n      // publish for edit post page\r\n      pubsub.publish(COMMENT_SUBSCRIPTION, {\r\n        commentUpdated: {\r\n          mutation: 'CREATED',\r\n          id: comment.id,\r\n          postId: input.postId,\r\n          node: comment\r\n        }\r\n      });\r\n      return comment;\r\n    },\r\n    async deleteComment(obj: any, { input: { id, postId } }: CommentInputWithId, context: any) {\r\n      await context.Post.deleteComment(id);\r\n      // publish for edit post page\r\n      pubsub.publish(COMMENT_SUBSCRIPTION, {\r\n        commentUpdated: {\r\n          mutation: 'DELETED',\r\n          id,\r\n          postId,\r\n          node: null\r\n        }\r\n      });\r\n      return { id };\r\n    },\r\n    async editComment(obj: any, { input }: CommentInputWithId, context: any) {\r\n      await context.Post.editComment(input);\r\n      const comment = await context.Post.getComment(input.id);\r\n      // publish for edit post page\r\n      pubsub.publish(COMMENT_SUBSCRIPTION, {\r\n        commentUpdated: {\r\n          mutation: 'UPDATED',\r\n          id: input.id,\r\n          postId: input.postId,\r\n          node: comment\r\n        }\r\n      });\r\n      return comment;\r\n    }\r\n  },\r\n  Subscription: {\r\n    postUpdated: {\r\n      subscribe: withFilter(\r\n        () => pubsub.asyncIterator(POST_SUBSCRIPTION),\r\n        (payload, variables) => {\r\n          return payload.postUpdated.id === variables.id;\r\n        }\r\n      )\r\n    },\r\n    postsUpdated: {\r\n      subscribe: withFilter(\r\n        () => pubsub.asyncIterator(POSTS_SUBSCRIPTION),\r\n        (payload, variables) => {\r\n          return variables.endCursor <= payload.postsUpdated.id;\r\n        }\r\n      )\r\n    },\r\n    commentUpdated: {\r\n      subscribe: withFilter(\r\n        () => pubsub.asyncIterator(COMMENT_SUBSCRIPTION),\r\n        (payload, variables) => {\r\n          return payload.commentUpdated.postId === variables.postId;\r\n        }\r\n      )\r\n    }\r\n  }\r\n});","\n    var doc = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"title\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"comments\"},\"arguments\":[],\"type\":{\"kind\":\"ListType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"}}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"PostEdges\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"node\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"cursor\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"PostPageInfo\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"endCursor\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"hasNextPage\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Boolean\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"Posts\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"totalCount\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"edges\"},\"arguments\":[],\"type\":{\"kind\":\"ListType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"PostEdges\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"pageInfo\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"PostPageInfo\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeExtension\",\"name\":{\"kind\":\"Name\",\"value\":\"Query\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"posts\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"after\"},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Posts\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"post\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeExtension\",\"name\":{\"kind\":\"Name\",\"value\":\"Mutation\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"addPost\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"input\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"AddPostInput\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"deletePost\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"editPost\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"input\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"EditPostInput\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"addComment\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"input\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"AddCommentInput\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"deleteComment\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"input\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"DeleteCommentInput\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"editComment\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"input\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"EditCommentInput\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"}},\"directives\":[]}]},{\"kind\":\"InputObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"AddPostInput\"},\"directives\":[],\"fields\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"title\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]}]},{\"kind\":\"InputObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"EditPostInput\"},\"directives\":[],\"fields\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"title\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]}]},{\"kind\":\"InputObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"AddCommentInput\"},\"directives\":[],\"fields\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postId\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}]},{\"kind\":\"InputObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"DeleteCommentInput\"},\"directives\":[],\"fields\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postId\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}]},{\"kind\":\"InputObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"EditCommentInput\"},\"directives\":[],\"fields\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"content\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postId\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}]},{\"kind\":\"ObjectTypeExtension\",\"name\":{\"kind\":\"Name\",\"value\":\"Subscription\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postUpdated\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"UpdatePostPayload\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postsUpdated\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"endCursor\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"UpdatePostPayload\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"commentUpdated\"},\"arguments\":[{\"kind\":\"InputValueDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postId\"},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]}],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"UpdateCommentPayload\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"UpdatePostPayload\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"mutation\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"node\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Post\"}},\"directives\":[]}]},{\"kind\":\"ObjectTypeDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"UpdateCommentPayload\"},\"interfaces\":[],\"directives\":[],\"fields\":[{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"mutation\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"postId\"},\"arguments\":[],\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},\"directives\":[]},{\"kind\":\"FieldDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"node\"},\"arguments\":[],\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Comment\"}},\"directives\":[]}]}],\"loc\":{\"start\":0,\"end\":2202}};\n    doc.loc.source = {\"body\":\"# Post\\r\\ntype Post {\\r\\n  id: Int!\\r\\n  title: String!\\r\\n  content: String!\\r\\n  comments: [Comment]\\r\\n}\\r\\n\\r\\n# Comment\\r\\ntype Comment {\\r\\n  id: Int!\\r\\n  content: String!\\r\\n}\\r\\n\\r\\n# Edges for Posts\\r\\ntype PostEdges {\\r\\n  node: Post\\r\\n  cursor: Int\\r\\n}\\r\\n\\r\\n# PageInfo for Posts\\r\\ntype PostPageInfo {\\r\\n  endCursor: Int\\r\\n  hasNextPage: Boolean\\r\\n}\\r\\n\\r\\n# Posts relay-style pagination query\\r\\ntype Posts {\\r\\n  totalCount: Int\\r\\n  edges: [PostEdges]\\r\\n  pageInfo: PostPageInfo\\r\\n}\\r\\n\\r\\nextend type Query {\\r\\n  # Posts pagination query\\r\\n  posts(limit: Int, after: Int): Posts\\r\\n  # Post\\r\\n  post(id: Int!): Post\\r\\n}\\r\\n\\r\\nextend type Mutation {\\r\\n  # Create new post\\r\\n  addPost(input: AddPostInput!): Post\\r\\n  # Delete a post\\r\\n  deletePost(id: Int!): Post\\r\\n  # Edit a post\\r\\n  editPost(input: EditPostInput!): Post\\r\\n  # Add comment to post\\r\\n  addComment(input: AddCommentInput!): Comment\\r\\n  # Delete a comment\\r\\n  deleteComment(input: DeleteCommentInput!): Comment\\r\\n  # Edit a comment\\r\\n  editComment(input: EditCommentInput!): Comment\\r\\n}\\r\\n\\r\\n# Input for addPost Mutation\\r\\ninput AddPostInput {\\r\\n  title: String!\\r\\n  content: String!\\r\\n}\\r\\n\\r\\n# Input for editPost Mutation\\r\\ninput EditPostInput {\\r\\n  id: Int!\\r\\n  title: String!\\r\\n  content: String!\\r\\n}\\r\\n\\r\\n# Input for addComment Mutation\\r\\ninput AddCommentInput {\\r\\n  content: String!\\r\\n  # Needed for commentUpdated Subscription filter\\r\\n  postId: Int!\\r\\n}\\r\\n\\r\\n# Input for editComment Mutation\\r\\ninput DeleteCommentInput {\\r\\n  id: Int!\\r\\n  # Needed for commentUpdated Subscription filter\\r\\n  postId: Int!\\r\\n}\\r\\n\\r\\n# Input for deleteComment Mutation\\r\\ninput EditCommentInput {\\r\\n  id: Int!\\r\\n  content: String!\\r\\n  # Needed for commentUpdated Subscription filter\\r\\n  postId: Int!\\r\\n}\\r\\n\\r\\nextend type Subscription {\\r\\n  # Subscription for when editing a post\\r\\n  postUpdated(id: Int!): UpdatePostPayload\\r\\n  # Subscription for post list\\r\\n  postsUpdated(endCursor: Int!): UpdatePostPayload\\r\\n  # Subscription for comments\\r\\n  commentUpdated(postId: Int!): UpdateCommentPayload\\r\\n}\\r\\n\\r\\n# Payload for postsUpdated Subscription\\r\\ntype UpdatePostPayload {\\r\\n  mutation: String!\\r\\n  id: Int!\\r\\n  node: Post\\r\\n}\\r\\n\\r\\n# Payload for commentUpdated Subscription\\r\\ntype UpdateCommentPayload {\\r\\n  mutation: String!\\r\\n  id: Int\\r\\n  postId: Int!\\r\\n  node: Comment\\r\\n}\",\"name\":\"GraphQL request\",\"locationOffset\":{\"line\":1,\"column\":1}};\n  \r\n\n    var names = {};\n    function unique(defs) {\n      return defs.filter(\n        function(def) {\n          if (def.kind !== 'FragmentDefinition') return true;\n          var name = def.name.value\n          if (names[name]) {\n            return false;\n          } else {\n            names[name] = true;\n            return true;\n          }\n        }\n      )\n    }\n  \r\n\n      module.exports = doc;\n    \r\n","import { knex, returnId, orderedFor } from '@bunker42/database-server';\r\n\r\nexport interface Post {\r\n  title: string;\r\n  content: string;\r\n}\r\n\r\nexport interface Comment {\r\n  postId: number;\r\n  content: string;\r\n}\r\n\r\nexport interface Identifier {\r\n  id: number;\r\n}\r\n\r\nexport default class PostDAO {\r\n  public postsPagination(limit: number, after: number) {\r\n    return knex\r\n      .select('id', 'title', 'content')\r\n      .from('post')\r\n      .orderBy('id', 'desc')\r\n      .limit(limit)\r\n      .offset(after);\r\n  }\r\n\r\n  public async getCommentsForPostIds(postIds: number[]) {\r\n    const res = await knex\r\n      .select('id', 'content', 'post_id AS postId')\r\n      .from('comment')\r\n      .whereIn('post_id', postIds);\r\n\r\n    return orderedFor(res, postIds, 'postId', false);\r\n  }\r\n\r\n  public getTotal() {\r\n    return knex('post')\r\n      .countDistinct('id as count')\r\n      .first();\r\n  }\r\n\r\n  public post(id: number) {\r\n    return knex\r\n      .select('id', 'title', 'content')\r\n      .from('post')\r\n      .where('id', '=', id)\r\n      .first();\r\n  }\r\n\r\n  public addPost(params: Post) {\r\n    return returnId(knex('post')).insert(params);\r\n  }\r\n\r\n  public deletePost(id: number) {\r\n    return knex('post')\r\n      .where('id', '=', id)\r\n      .del();\r\n  }\r\n\r\n  public editPost({ id, title, content }: Post & Identifier) {\r\n    return knex('post')\r\n      .where('id', '=', id)\r\n      .update({ title, content });\r\n  }\r\n\r\n  public addComment({ content, postId }: Comment) {\r\n    return returnId(knex('comment')).insert({ content, post_id: postId });\r\n  }\r\n\r\n  public getComment(id: number) {\r\n    return knex\r\n      .select('id', 'content')\r\n      .from('comment')\r\n      .where('id', '=', id)\r\n      .first();\r\n  }\r\n\r\n  public deleteComment(id: number) {\r\n    return knex('comment')\r\n      .where('id', '=', id)\r\n      .del();\r\n  }\r\n\r\n  public editComment({ id, content }: Comment & Identifier) {\r\n    return knex('comment')\r\n      .where('id', '=', id)\r\n      .update({\r\n        content\r\n      });\r\n  }\r\n}","/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\nimport { FetchResult } from 'apollo-link';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: FetchResult<T>) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult!);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult<TData>(\n    queryId: string,\n    result: FetchResult<TData>,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: FetchResult<T>) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.6.10\"","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n","  \r\nimport modules from './modules';\r\n\r\n(async () => {\r\n  await modules.createApp(module);\r\n})();\r\n\r\nexport default modules;","import core from '@bunker42/core-client';\r\n// import look from '@bunker42/look-client-react';\r\n// import i18n from '@bunker42/i18n-client-react';\r\n// import counter from '@bunker42/counter-client-react';\r\n// import chat from '@bunker42/chat-client-react';\r\n// import contact from '@bunker42/contact-client-react';\r\n// import validation from '@bunker42/validation-common-react';\r\nimport ClientModule from '@bunker42/module-client';\r\n// import defaultRouter from '@bunker42/router-client-react';\r\n// import payments from '@bunker42/payments-client-react';\r\n// import authentication from '@bunker42/authentication-client-react';\r\n// import '@bunker42/favicon-common';\r\n\r\n// const post = require('@bunkre42/post-client-react').default;\r\n// const pageNotFound = require('@bunkre42/page-not-found-client-react').default;\r\n// const reports = require('@bunkre42/reports-client-react').default;\r\n// const upload = require('@bunkre42/upload-client-react').default;\r\n// const pagination = require('@bunkre42/pagination-client-react').default;\r\n// const user = require('@bunkre42/user-client-react').default;\r\n\r\nconst modules = new ClientModule(\r\n//   look,\r\n//   validation,\r\n//   defaultRouter,\r\n//   counter,\r\n//   post,\r\n//   upload,\r\n//   contact,\r\n//   pagination,\r\n//   chat,\r\n//   payments,\r\n//   user,\r\n//   i18n,\r\n//   reports,\r\n//   pageNotFound,\r\n  core,\r\n//   authentication\r\n);\r\n\r\nexport default modules;","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(updatedModules, renewedModules) {\n\tvar unacceptedModules = updatedModules.filter(function(moduleId) {\n\t\treturn renewedModules && renewedModules.indexOf(moduleId) < 0;\n\t});\n\tvar log = require(\"./log\");\n\n\tif (unacceptedModules.length > 0) {\n\t\tlog(\n\t\t\t\"warning\",\n\t\t\t\"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\"\n\t\t);\n\t\tunacceptedModules.forEach(function(moduleId) {\n\t\t\tlog(\"warning\", \"[HMR]  - \" + moduleId);\n\t\t});\n\t}\n\n\tif (!renewedModules || renewedModules.length === 0) {\n\t\tlog(\"info\", \"[HMR] Nothing hot updated.\");\n\t} else {\n\t\tlog(\"info\", \"[HMR] Updated modules:\");\n\t\trenewedModules.forEach(function(moduleId) {\n\t\t\tif (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n\t\t\t\tvar parts = moduleId.split(\"!\");\n\t\t\t\tlog.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t\tlog.groupEnd(\"info\");\n\t\t\t} else {\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t}\n\t\t});\n\t\tvar numberIds = renewedModules.every(function(moduleId) {\n\t\t\treturn typeof moduleId === \"number\";\n\t\t});\n\t\tif (numberIds)\n\t\t\tlog(\n\t\t\t\t\"info\",\n\t\t\t\t\"[HMR] Consider using the NamedModulesPlugin for module names.\"\n\t\t\t);\n\t}\n};\n","var logLevel = \"info\";\n\nfunction dummy() {}\n\nfunction shouldLog(level) {\n\tvar shouldLog =\n\t\t(logLevel === \"info\" && level === \"info\") ||\n\t\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\n\t\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\n\treturn shouldLog;\n}\n\nfunction logGroup(logFn) {\n\treturn function(level, msg) {\n\t\tif (shouldLog(level)) {\n\t\t\tlogFn(msg);\n\t\t}\n\t};\n}\n\nmodule.exports = function(level, msg) {\n\tif (shouldLog(level)) {\n\t\tif (level === \"info\") {\n\t\t\tconsole.log(msg);\n\t\t} else if (level === \"warning\") {\n\t\t\tconsole.warn(msg);\n\t\t} else if (level === \"error\") {\n\t\t\tconsole.error(msg);\n\t\t}\n\t}\n};\n\n/* eslint-disable node/no-unsupported-features/node-builtins */\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\n/* eslint-enable node/no-unsupported-features/node-builtins */\n\nmodule.exports.group = logGroup(group);\n\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\n\nmodule.exports.groupEnd = logGroup(groupEnd);\n\nmodule.exports.setLogLevel = function(level) {\n\tlogLevel = level;\n};\n\nmodule.exports.formatError = function(err) {\n\tvar message = err.message;\n\tvar stack = err.stack;\n\tif (!stack) {\n\t\treturn message;\n\t} else if (stack.indexOf(message) < 0) {\n\t\treturn message + \"\\n\" + stack;\n\t} else {\n\t\treturn stack;\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*globals __resourceQuery */\nif (module.hot) {\n\tvar hotPollInterval = +__resourceQuery.substr(1) || 10 * 60 * 1000;\n\tvar log = require(\"./log\");\n\n\tvar checkForUpdate = function checkForUpdate(fromUpdate) {\n\t\tif (module.hot.status() === \"idle\") {\n\t\t\tmodule.hot\n\t\t\t\t.check(true)\n\t\t\t\t.then(function(updatedModules) {\n\t\t\t\t\tif (!updatedModules) {\n\t\t\t\t\t\tif (fromUpdate) log(\"info\", \"[HMR] Update applied.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trequire(\"./log-apply-result\")(updatedModules, updatedModules);\n\t\t\t\t\tcheckForUpdate(true);\n\t\t\t\t})\n\t\t\t\t.catch(function(err) {\n\t\t\t\t\tvar status = module.hot.status();\n\t\t\t\t\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Cannot apply update.\");\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] \" + log.formatError(err));\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] You need to restart the application!\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t};\n\tsetInterval(checkForUpdate, hotPollInterval);\n} else {\n\tthrow new Error(\"[HMR] Hot Module Replacement is disabled.\");\n}\n","import 'dotenv/config';\r\nimport modules from './modules';\r\n\r\n(async () => {\r\n  await modules.createApp(module);\r\n})();\r\n\r\nexport default modules;","import core from '@bunker42/core-server';\r\n// import i18n from '@bunker42/i18n-server-ts';\r\n// import validation from '@bunker42/validation-common-react';\r\n// import counter from '@bunker42/counter-server-ts';\r\n// import chat from '@bunker42/chat-server-ts';\r\n// import contact from '@bunker42/contact-server-ts';\r\n// import cookies from '@bunker42/cookies-server-ts';\r\nimport post from '@bunker42/post-server';\r\n// import upload from '@bunker42/upload-server-ts';\r\n// import subscription from '@bunker42/payments-server-ts';\r\n// import mailer from '@bunker42/mailer-server-ts';\r\n// import graphqlTypes from '@bunker42/graphql-types-server-ts';\r\n// import authentication from '@bunker42/authentication-server-ts';\r\n// import reports from '@bunker42/reports-server-ts';\r\n// import rest from '@bunker42/rest-server-ts';\r\n// import '@bunker42/debug-server-ts';\r\n\r\nimport ServerModule from '@bunker42/module-server';\r\n\r\n// const user = require('@bunker42/user-server-ts').default;\r\n\r\nconst modules: ServerModule = new ServerModule(\r\n//   authentication,\r\n//   cookies,\r\n//   i18n,\r\n//   validation,\r\n//   counter,\r\n  post,\r\n//   subscription,\r\n//   user,\r\n//   upload,\r\n//   contact,\r\n//   mailer,\r\n//   chat,\r\n//   reports,\r\n//   rest,\r\n//   graphqlTypes,\r\n  core\r\n);\r\n\r\nexport default modules;","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@babel/runtime/helpers/extends\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"@loadable/server\");","module.exports = require(\"apollo-cache-inmemory\");","module.exports = require(\"apollo-cache-router\");","module.exports = require(\"apollo-link\");","module.exports = require(\"apollo-link-batch-http\");","module.exports = require(\"apollo-link-schema\");","module.exports = require(\"apollo-link-state\");","module.exports = require(\"apollo-link-ws\");","module.exports = require(\"apollo-logger\");","module.exports = require(\"apollo-server-express\");","module.exports = require(\"apollo-server-module-graphiql\");","module.exports = require(\"apollo-utilities\");","module.exports = require(\"compression\");","module.exports = require(\"connected-react-router\");","module.exports = require(\"dotenv/config\");","module.exports = require(\"express\");","module.exports = require(\"fractal-objects\");","module.exports = require(\"fs\");","module.exports = require(\"glob\");","module.exports = require(\"graphql\");","module.exports = require(\"graphql-resolve-batch\");","module.exports = require(\"graphql-subscriptions\");","module.exports = require(\"graphql-tools\");","module.exports = require(\"graphql/language/visitor\");","module.exports = require(\"http\");","module.exports = require(\"isomorphic-fetch\");","module.exports = require(\"isomorphic-unfetch\");","module.exports = require(\"knex\");","module.exports = require(\"lodash\");","module.exports = require(\"minilog\");","module.exports = require(\"module\");","module.exports = require(\"objection\");","module.exports = require(\"path\");","module.exports = require(\"raf/polyfill\");","module.exports = require(\"react\");","module.exports = require(\"react-apollo\");","module.exports = require(\"react-dom/server\");","module.exports = require(\"react-helmet\");","module.exports = require(\"react-redux\");","module.exports = require(\"react-router\");","module.exports = require(\"redux\");","module.exports = require(\"redux-devtools-extension/developmentOnly\");","module.exports = require(\"serialize-javascript\");","module.exports = require(\"styled-components\");","module.exports = require(\"subscriptions-transport-ws\");","module.exports = require(\"symbol-observable\");","module.exports = require(\"ts-invariant\");","module.exports = require(\"tslib\");","module.exports = require(\"url\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9yBA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAVA;;;;;;;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAFA;AACA;AAaA;AACA;AACA,aAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAPA;AAWA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;;;;;;ACvCA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAFA;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AACA;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AADA;AAEA;AADA;AADA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAVA;AADA;AACA;AAYA;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAJA;AACA;AAOA;AACA;AACA;AAGA;AACA;AACA;AAHA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAFA;AAOA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AAEA;AAEA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AAEA;AAEA;AADA;AACA;AAIA;AAMA;AAGA;AAEA;AACA;AACA;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAOA;AAEA;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAUA;AAEA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AAEA;AACA;AAFA;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAwBA;AACA;AAFA;AAKA;AACA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,eAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAHA;AAKA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAhBA;AAkBA;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AADA;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;AANA;AAUA;AACA;AACA;AACA;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AAUA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAQA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AADA;AADA;AAKA;AANA;AACA;AAWA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AASA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA,mBAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAGA;AACA;AACA;AAFA;AAGA;AARA;AADA;AAaA;AACA;AACA;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;;;;;;ACVA;AAAA;AAAA;AAEA;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACFA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAEA;;;;AAqBA;;;AAGA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AA7CA;AACA;AA8CA;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;AAcA;;;AAGA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;AAGA;AACA;AAEA;AAAA;AAEA;AAEA;;;;;AAGA;AACA;AAGA;AADA;AAIA;AAEA;;;;;AAGA;AACA;AAGA;AADA;AAIA;AACA;AA5CA;AACA;AA6CA;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACAA;AAAA;AAAA;AAEA;;;;AAYA;;;AAGA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AAjBA;AACA;AAkBA;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAMA;AAEA;;;;;;;;;AA+CA;;;AAGA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AAxBA;AACA;AAyBA;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAEA;;;;;;AAmBA;;;;;;AAMA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;AACA;AAmCA;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAgEA;;;;;AAKA;AACA;;;;;;AAMA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;;;;;;;;AAUA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;;;;;;;;;AAOA;AACA;AACA;AACA;AAxDA;AACA;AAyDA;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAHA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AA6BA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AA3BA;AA4BA;AACA;AACA;AAAA;AAAA;AACA;AAHA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AACA;AAOA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AACA;AAOA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AAQA;AACA;AACA;AArGA;AAsGA;AACA;AACA;AAGA;AACA;AALA;AAQA;AACA;AAGA;AACA;AALA;AAQA;AACA;AAGA;AACA;AALA;AAjBA;AAxIA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAgBA;AACA;AACA;AAMA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AADA;AAGA;AACA;AA1EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AADA;AAMA;AAMA;AAMA;AAMA;AAOA;AAKA;AAKA;AACA;AACA;AAKA;AAGA;AACA;AACA;AC9CA;AAAA;AACA;AADA;;AAQA;AACA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AARA;AACA;ACXA;AACA;AACA;AACA;ACAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AACA;AACA;AAAA;AAxCA;AACA;ACJA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AC4BA;AAEA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAGA;AACA;AAmBA;AACA;AACA;AACA;AAAA;AACA;AAJA;AAUA;AAAA;AACA;AAlBA;AACA;AAoBA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AACA;AAwBA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAJA;AASA;AACA;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AAEA;AAOA;AAGA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAIA;AACA;AAIA;AAIA;AADA;AAMA;AADA;AACA;AAGA;AAEA;AASA;AACA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAIA;AAAA;AACA;AASA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAnBA;AAsBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AA4BA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAIA;AACA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAsCA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAtmBA;AACA;AAumBA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAIA;AACA;ACtsBA;AAAA;AACA;AA0CA;AACA;AAzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AC9BA;AAAA;AACA;AAgKA;AACA;AA/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAKA;AAUA;AAEA;AACA;AAAA;AAKA;;;;;;AAOA;AACA;;;;;;;;AASA;;;AAEA;AACA;;AAKA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAgBA;AAhBA;AACA;AAkBA;;;AA/EA;AACA;;AA0FA;AAEA;AACA;AAKA;AAEA;AACA;AACA;;;;;;AAWA;AAMA;AACA;AACA;;;;;;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;AAMA;AAEA;AAFA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;AAOA;AACA;;AAlKA;AACA;ACjBA;AACA;AACA;AACA;ACqEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AAQA;AACA;AAOA;AAEA;AADA;AAEA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAZA;AACA;AAcA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AACA;AACA;AAKA;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AADA;AAiBA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AACA;AACA;AACA;AAEA;AAGA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAXA;AAcA;AAIA;AACA;AACA;AAFA;AAGA;;;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AAAA;;;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;;;AAxCA;AAwCA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAzBA;AA4BA;AACA;AAAA;AAAA;AACA;AACA;AACA;AC/BA;AACA;AAeA;AA6BA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAnCA;AACA;AAKA;AAQA;AAIA;AAOA;AAujBA;AAkcA;AAgPA;AAptCA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;;;;;;;;;AAEA;AAKA;AAKA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;AADA;;;;AAIA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AADA;AAMA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AADA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AA7GA;AA+GA;;;;AACA;AACA;AACA;;;;;;;;;AAUA;AAKA;AAEA;AAEA;AACA;AACA;;AADA;;;;AAGA;AAAA;AAAA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAGA;AAKA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AALA;AAOA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;;;;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAGA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AAKA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAJA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AARA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAQA;AAEA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AAMA;AAKA;AAKA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AAUA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAPA;AASA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAKA;AAIA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAOA;AACA;AAAA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AALA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;AACA;AAiBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AADA;AAGA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAQA;AAAA;AACA;AAIA;AAEA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;ACx2CA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AC7MA;ACuCA;AACA;AAuBA;AAkDA;AAAA;AACA;AA3CA;AAIA;AACA;AAuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAKA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAMA;AAIA;AAMA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AANA;AAQA;AACA;AAtBA;AAwBA;AACA;AAKA;AACA;AACA;AACA;AAoBA;AAGA;AACA;AAIA;AACA;AAEA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAUA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAQA;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AAKA;AAGA;AACA;AACA;AAUA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAeA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AAYA;AAGA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AAiBA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAaA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AC1kBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;;;;;;;ACvBA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1DA;;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;ACxCA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;A","sourceRoot":""}